# Клиенты Ethereum

Клиент Ethereum - это программное приложение, которое реализует спецификацию Ethereum и взаимодействует через одноранговую сеть с другими клиентами Ethereum. Различные клиенты Ethereum взаимодействуют между собой, если они соответствуют эталонной спецификации и стандартизированным протоколам связи. Хотя эти разные клиенты реализованы разными командами и на разных языках программирования, все они "говорят" на одном протоколе и следуют одним и тем же правилам. Поэтому все они могут использоваться для работы и взаимодействия с одной и той же сетью Ethereum.

Ethereum - проект с открытым исходным кодом, и исходный код всех основных клиентов доступен под лицензией с открытым исходным кодом (например, LGPL v3.0), его можно свободно скачивать и использовать в любых целях. Однако открытый исходный код означает не только свободу использования. Это также означает, что Ethereum разрабатывается открытым сообществом добровольцев и может быть изменен любым желающим. Больше глаз означает более надежный код.

Ethereum определяется формальной спецификацией под названием "Желтая книга" (см. [ссылки]).

В отличие, например, от Биткойна, который не имеет никакого формального определения. Если "спецификацией" Bitcoin является эталонная реализация Bitcoin Core, то спецификация Ethereum документирована в документе, который сочетает в себе английскую и математическую (формальную) спецификации. Эта формальная спецификация, в дополнение к различным предложениям по улучшению Ethereum, определяет стандартное поведение клиента Ethereum. Желтый документ периодически обновляется по мере внесения в Ethereum значительных изменений.

В результате четкой формальной спецификации Ethereum существует ряд независимо разработанных, но совместимых между собой программных реализаций клиента Ethereum. Ethereum имеет большее разнообразие реализаций, работающих в сети, чем любой другой блокчейн, что в целом считается положительным моментом. Действительно, это, например, оказалось отличным способом защиты от атак на сеть, поскольку эксплуатация стратегии реализации конкретного клиента просто доставляет разработчикам хлопоты, пока они исправляют ее, в то время как другие клиенты поддерживают работу сети практически незатронутой.

## Сети Ethereum
Существует множество сетей на базе Ethereum, которые в основном соответствуют формальной спецификации, определенной в "желтой книге" Ethereum, но могут взаимодействовать или не взаимодействовать друг с другом.

Среди таких сетей на основе Ethereum - Ethereum, Ethereum Classic, Ella, Expanse, Ubiq, Musicoin и многие другие. Хотя эти сети в основном совместимы на уровне протокола, они часто имеют особенности или атрибуты, которые требуют от разработчиков клиентского программного обеспечения Ethereum внесения небольших изменений для поддержки каждой сети. В связи с этим не каждая версия клиентского программного обеспечения Ethereum поддерживает все блокчейны на базе Ethereum.

В настоящее время существует шесть основных реализаций протокола Ethereum, написанных на шести разных языках:

- Parity, написанная на языке Rust
- Geth, написанный на языке Go
- cpp-ethereum, написанная на C++
- pyethereum, написан на Python
- Mantis, написан на Scala
- Harmony, написана на Java

В этом разделе мы рассмотрим два наиболее распространенных клиента - Parity и Geth. Мы покажем, как настроить узел с помощью каждого клиента, а также изучим некоторые опции командной строки и интерфейсы прикладного программирования (API).

### Должен ли я запускать полный узел?
Здоровье, устойчивость и устойчивость к цензуре блокчейн зависит от наличия множества независимо управляемых и географически разнесенных полных узлов. Каждый полный узел может помочь другим новым узлам получить данные блока для начала работы, а также предложить оператору авторитетную и независимую проверку всех транзакций и контрактов.

Однако работа полного узла требует затрат на аппаратные ресурсы и пропускную способность. Полный узел может загружать до 300 ГБ данных (по состоянию на март 2021 года, в зависимости от конфигурации клиента) и хранить их на локальном жестком диске. Эта нагрузка на данные довольно быстро возрастает каждый день по мере добавления новых транзакций и блоков. Мы обсуждаем эту тему более подробно в разделе "Требования к аппаратному обеспечению для полного узла".

Для разработки Ethereum не обязательно иметь полноценный узел, работающий в реальной сети mainnet. Вы можете делать почти все необходимое с помощью узла testnet (который подключает вас к одному из небольших публичных тестовых блокчейнов), локального частного блокчейна, например Ganache, или облачного клиента Ethereum, предлагаемого поставщиком услуг, например Infura.

У вас также есть возможность запустить удаленный клиент, который не хранит локальную копию блокчейна и не подтверждает блоки и транзакции. Эти клиенты обладают функциональностью кошелька и могут создавать и транслировать транзакции. Удаленные клиенты могут использоваться для подключения к существующим сетям, таким как ваш собственный полный узел, публичный блокчейн, публичный или разрешенный (доказательство полномочий) тестнет или частный локальный блокчейн. На практике вы, скорее всего, будете использовать удаленный клиент, такой как MetaMask, Emerald Wallet, MyEtherWallet или MyCrypto, как удобный способ переключения между всеми различными вариантами узлов.

Термины "удаленный клиент" и "кошелек" используются как взаимозаменяемые, хотя есть и некоторые различия. Обычно удаленный клиент предлагает API (например, API web3.js) в дополнение к функциональности транзакций кошелька.

Не путайте понятие удаленного кошелька в Ethereum с понятием легкого клиента (который является аналогом клиента упрощенной верификации платежей в Bitcoin). Легкие клиенты проверяют заголовки блоков и используют доказательства Меркла для подтверждения включения транзакций в блокчейн и определения их последствий, что обеспечивает им уровень безопасности, аналогичный полному узлу. И наоборот, удаленные клиенты Ethereum не проверяют заголовки блоков или транзакции. Они полностью доверяют полному клиенту, который предоставляет им доступ к блокчейну, и, следовательно, теряют значительные гарантии безопасности и анонимности. Вы можете уменьшить эти проблемы, используя полный клиент, который вы запускаете самостоятельно.

### Преимущества и недостатки полного узла
Выбор полного узла помогает в работе сетей, к которым вы его подключаете, но также влечет за собой некоторые легкие или умеренные расходы для вас. Давайте рассмотрим некоторые преимущества и недостатки.

#### Преимущества:

- Поддерживает устойчивость и цензуроустойчивость сетей на базе Ethereum
- Авторитетно подтверждает все транзакции
- Может взаимодействовать с любым контрактом на публичном блокчейне без посредника
- Может напрямую внедрять контракты в публичный блокчейн без посредника
- Может запрашивать (только для чтения) состояние блокчейна (счета, контракты и т.д.) в автономном режиме
- Можно запрашивать блокчейн, не позволяя третьим лицам узнать информацию, которую вы читаете.
  
#### Недостатки:

- Требует значительных и постоянно растущих аппаратных ресурсов и пропускной способности.
- При первом запуске может потребоваться несколько дней для полной синхронизации
- Необходимо поддерживать, обновлять и держать в сети, чтобы синхронизация сохранялась.

### Преимущества и недостатки публичной сети Testnet
Независимо от того, решите ли вы запустить полноценный узел, вы, вероятно, захотите запустить публичный узел тестовой сети. Давайте рассмотрим некоторые преимущества и недостатки использования публичной тестовой сети.

#### Преимущества:

- Узлу testnet требуется синхронизировать и хранить значительно меньше данных по сравнению с mainnet - около 75 ГБ в зависимости от сети.
- Узел testnet может полностью синхронизироваться за гораздо меньшее время.
- Для развертывания контрактов или совершения транзакций требуется тестовый эфир, который не имеет стоимости и может быть получен бесплатно из нескольких "кранов".
- Тестовые сети - это публичные блокчейны с множеством других пользователей и контрактов, работающие "вживую".

#### Недостатки:

- Вы не можете использовать "реальные" деньги в тестнете; он работает на тестовом эфире. Следовательно, вы не можете проверить безопасность против реальных противников, поскольку на кону ничего нет.
- Есть некоторые аспекты публичного блокчейна, которые невозможно реалистично проверить в тестовой сети. Например, плата за транзакции, хотя она и необходима для отправки транзакций, в тестовой сети не учитывается, поскольку газ бесплатен. Кроме того, тестовые сети не испытывают перегрузок сети, как это иногда происходит в публичной основной сети.

### Преимущества и недостатки моделирования локального блокчейна
Для многих целей тестирования лучшим вариантом является запуск приватного блокчейна, состоящего из одного экземпляра. Ganache (прежнее название testrpc) - одна из самых популярных локальных симуляций блокчейна, с которой вы можете взаимодействовать без каких-либо других участников. Он разделяет многие преимущества и недостатки публичного testnet, но имеет и некоторые отличия.

#### Преимущества:

- Отсутствие синхронизации и почти полное отсутствие данных на диске; вы сами добываете первый блок.
- Нет необходимости получать тестовый эфир; Ganache инициализируется учетными записями, на которых уже хранится эфир для тестирования
- Нет других пользователей, только вы
- Никаких других контрактов, только те, которые вы развертываете после запуска, если только вы не используете опцию форка существующего узла Ethereum.

#### Недостатки:

- Отсутствие других пользователей означает, что блокчейн ведет себя не так, как публичный блокчейн. Нет конкуренции за место для транзакций или последовательность транзакций.
- Отсутствие других майнеров, кроме вас, означает, что майнинг более предсказуем; поэтому вы не можете проверить некоторые сценарии, которые происходят на публичном блокчейне.
- Если вы создаете узел Ethereum, он должен быть архивным узлом, чтобы вы могли взаимодействовать с состоянием блоков, которые в противном случае могли быть обрезаны.

## Запуск клиента Ethereum
Если у вас есть время и ресурсы, вам стоит попробовать запустить полноценный узел, хотя бы для того, чтобы узнать больше о процессе. В этом разделе мы расскажем, как загрузить, скомпилировать и запустить клиенты Ethereum Parity и Geth. Это требует некоторого знакомства с использованием интерфейса командной строки в вашей операционной системе. Стоит установить эти клиенты независимо от того, будете ли вы запускать их как полноценные узлы, как узлы тестовой сети или как клиенты локального частного блокчейна.

### Аппаратные требования для полного узла
Прежде чем приступить к работе, необходимо убедиться, что у вас есть компьютер с достаточными ресурсами для запуска полного узла Ethereum. Вам потребуется не менее 300 ГБ дискового пространства для хранения полной копии блокчейна Ethereum. Если вы также хотите запустить полный узел в тестовой сети Ethereum, вам потребуется еще как минимум 75 ГБ. Загрузка 375 ГБ данных блокчейна может занять много времени, поэтому рекомендуется работать на быстром интернет-соединении.

Синхронизация блокчейна Ethereum требует больших затрат на ввод/вывод (I/O). Лучше всего иметь твердотельный накопитель (SSD). Если у вас механический жесткий диск (HDD), вам понадобится не менее 8 ГБ оперативной памяти для использования в качестве кэша. В противном случае вы можете обнаружить, что ваша система слишком медленная, чтобы поддерживать и полностью синхронизировать данные.

### Минимальные требования:

- процессор с 2+ ядрами
- Не менее 300 ГБ свободного места для хранения данных
- Минимум 4 ГБ ОЗУ с SSD, 8 ГБ+, если у вас есть HDD
- Интернет-сервис со скоростью загрузки 8 МБит/сек

Это минимальные требования для синхронизации полной (но обрезанной) копии блокчейна на базе Ethereum.

На момент написания статьи кодовая база Parity была менее требовательна к ресурсам, поэтому если вы работаете на ограниченном оборудовании, вы, скорее всего, получите лучшие результаты, используя Parity.

Если вы хотите синхронизироваться за разумное время и хранить все инструменты разработки, библиотеки, клиенты и блокчейн, которые мы обсуждаем в этой книге, вам понадобится более мощный компьютер.

### Рекомендуемые характеристики:

- Быстрый процессор с 4+ ядрами
- 16 ГБ+ ОПЕРАТИВНОЙ ПАМЯТИ
- Быстрый твердотельный накопитель с не менее чем 500 ГБ свободного места
- Интернет со скоростью загрузки 25+ МБит/сек

Трудно предсказать, как быстро будет увеличиваться размер блокчейна и когда потребуется больше дискового пространства, поэтому рекомендуется проверить последний размер блокчейна перед началом синхронизации.

__Примечание:__ Приведенные здесь требования к размеру диска предполагают, что вы запустите узел с настройками по умолчанию, при которых блокчейн "обрезается" от старых данных о состоянии. Если вместо этого вы запустите полностью "архивный" узел, где все состояние хранится на диске, то, скорее всего, потребуется более 1 ТБ дискового пространства.

По этим ссылкам можно найти актуальные оценки размера блокчейна:

- [Ethereum](https://bitinfocharts.com/ethereum/)
- [Ethereum Classic](https://bitinfocharts.com/ethereum%20classic/)

### Требования к программному обеспечению для создания и запуска клиента (узла)
В этом разделе рассматривается клиентское программное обеспечение Parity и Geth. Также предполагается, что вы используете Unix-подобную среду командной строки. В примерах показаны команды и вывод, как они выглядят в операционной системе Ubuntu GNU/Linux под управлением оболочки bash (среда выполнения командной строки).

Как правило, каждый блокчейн имеет свою собственную версию Geth, а Parity обеспечивает поддержку нескольких блокчейнов на базе Ethereum (Ethereum, Ethereum Classic, Ellaism, Expanse, Musicoin) с помощью одного загружаемого клиента.

__Совет:__ Во многих примерах в этой главе мы будем использовать интерфейс командной строки операционной системы (также известный как "оболочка"), доступ к которому осуществляется через приложение "терминал". Оболочка отображает приглашение; вы вводите команду, а оболочка отвечает некоторым текстом и новым приглашением для следующей команды. В вашей системе подсказка может выглядеть по-другому, но в следующих примерах она обозначается символом $. В примерах, когда вы видите текст после символа $, не вводите символ $, а введите команду, следующую сразу за ним (выделено жирным шрифтом), затем нажмите Enter для выполнения команды. В примерах строки под каждой командой - это ответы операционной системы на эту команду. Когда вы увидите следующий префикс $, вы поймете, что это новая команда, и вам следует повторить процесс.

Прежде чем мы начнем, вам может понадобиться установить некоторое программное обеспечение. Если вы никогда не занимались разработкой программного обеспечения на компьютере, который используете в данный момент, вам, вероятно, потребуется установить некоторые базовые инструменты. Для следующих примеров вам потребуется установить git, систему управления исходным кодом; golang, язык программирования Go и стандартные библиотеки; и Rust, язык системного программирования.

Git можно установить, следуя инструкциям на сайте https://git-scm.com.

Go можно установить, следуя инструкциям на https://golang.org или https://github.com/golang/go/wiki/Ubuntu, если вы используете Ubuntu.

__Примечание:__ Требования к Geth различны, но если вы придерживаетесь Go версии 1.13 или выше, вы сможете скомпилировать большинство версий Geth. Конечно, вы всегда должны обращаться к документации по выбранному вами варианту Geth. Версия golang, установленная в вашей операционной системе или доступная из менеджера пакетов вашей системы, может быть значительно старше 1.13. Если это так, удалите ее и установите последнюю версию с сайта https://golang.org/.

Rust можно установить, следуя инструкциям на https://www.rustup.rs/.

__Примечание:__ Для работы Parity требуется Rust версии 1.27 или выше.

Parity также требует наличия некоторых программных библиотек, таких как OpenSSL и libudev. Чтобы установить их на совместимую систему Ubuntu или Debian GNU/Linux, выполните следующую команду:

``$ sudo apt-get install openssl libssl-dev libudev-dev cmake clang``

Для других операционных систем используйте менеджер пакетов вашей ОС или следуйте инструкциям Wiki для установки необходимых библиотек.

Теперь, когда у вас установлены git, golang, Rust и необходимые библиотеки, давайте приступим к работе!

### Parity
Parity - это реализация полноузлового клиента Ethereum и браузера DApp. Он был написан "с нуля" на Rust, языке системного программирования, с целью создания модульного, безопасного и масштабируемого клиента Ethereum. Parity разработан британской компанией Parity Tech и выпускается под лицензией свободного программного обеспечения GPLv3.

__Примечание:__ Раскрытие информации: Один из авторов этой книги, доктор Гэвин Вуд, является основателем компании Parity Tech и написал большую часть клиента Parity. Parity составляет около 25% установленной клиентской базы Ethereum.

Чтобы установить Parity, вы можете использовать менеджер пакетов Rust cargo или загрузить исходный код с GitHub. Менеджер пакетов также загружает исходный код, поэтому между этими двумя вариантами нет особой разницы. В следующем разделе мы покажем вам, как загрузить и скомпилировать Parity самостоятельно.

#### Установка Parity
Parity Wiki предлагает инструкции по сборке Parity в различных средах и контейнерах. Мы покажем вам, как собрать Parity из исходников. Это предполагает, что вы уже установили Rust с помощью rustup (см. раздел Требования к программному обеспечению для сборки и запуска клиента (Node)).

Сначала возьмите исходный код с GitHub:

``$ git clone https://github.com/paritytech/parity``

Затем перейдите в каталог parity и используйте cargo для сборки исполняемого файла:

```bash
$ cd parity
$ cargo install --path .
```
Если все идет хорошо, вы должны увидеть что-то вроде:

```
$ cargo install --path .
Installing parity-ethereum v2.7.0 (/root/parity)
Updating crates.io index
Updating git repository `https://github.com/paritytech/rust-ctrlc.git`
Updating git repository `https://github.com/paritytech/app-dirs-rs`   Updating git repository

 [...]

Compiling parity-ethereum v2.7.0 (/root/parity)
Finished release [optimized] target(s) in 10m 16s
Installing /root/.cargo/bin/parity
Installed package `parity-ethereum v2.7.0 (/root/parity)` (executable `parity`)
$
```

Попробуйте запустить parity, чтобы проверить, установлен ли он, используя опцию --version:

```
$ parity --version
Parity Ethereum Client.
  version Parity-Ethereum/v2.7.0-unstable-b69a33b3a-20200124/x86_64-unknown-linux-gnu/rustc1.40.0
Copyright 2015-2020 Parity Technologies (UK) Ltd.
License GPLv3+: GNU GPL version 3 or later http://gnu.org/licenses/gpl.html.
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.

By Wood/Paronyan/Kotewicz/Drwięga/Volf/Greeff
   Habermeier/Czaban/Gotchac/Redman/Nikolsky
   Schoedon/Tang/Adolfsson/Silva/Palm/Hirsz et al.
$
```

Отлично! Теперь, когда Parity установлен, вы можете синхронизировать блокчейн и начать работу с некоторыми основными опциями командной строки.

### Go-Ethereum (Geth)
Geth - это реализация языка Go, которая активно разрабатывается Ethereum Foundation, поэтому считается "официальной" реализацией клиента Ethereum. Как правило, каждый блокчейн на базе Ethereum имеет свою собственную реализацию Geth. Если вы используете Geth, то вам нужно убедиться, что вы взяли правильную версию для вашего блокчейна, используя одну из следующих ссылок на репозиторий:

- Ethereum (или https://geth.ethereum.org/)
- [Ethereum Classic](https://github.com/etclabscore/go-ethereum)
- [Ellaism](https://github.com/ellaism/go-ellaism)
- [Expanse](https://github.com/expanse-org/go-expanse)
- [Musicoin](https://github.com/Musicoin/go-musicoin)
- [Ubiq](https://github.com/ubiq/go-ubiq)

__Примечание:__ Вы также можете пропустить эти инструкции и установить предварительно скомпилированный двоичный файл для выбранной вами платформы. Предварительно скомпилированные релизы гораздо проще установить, их можно найти в разделе "релизы" любого из перечисленных здесь репозиториев. Однако вы можете узнать больше, загрузив и скомпилировав программное обеспечение самостоятельно.

#### Клонирование репозитория
Первым шагом будет клонирование репозитория Git, чтобы получить копию исходного кода.

Чтобы создать локальный клон выбранного вами репозитория, используйте команду git следующим образом в вашем домашнем каталоге или в любом каталоге, который вы используете для разработки:

``$ git clone <Ссылка на репозиторий>.``

Вы увидите отчет о прогрессе, когда репозиторий будет скопирован в вашу локальную систему:

```
Cloning into 'go-ethereum'...
remote: Enumerating objects: 86915, done.
remote: Total 86915 (delta 0), reused 0 (delta 0), pack-reused 86915
Receiving objects: 100% (86915/86915), 134.73 MiB | 29.30 MiB/s, done.
Resolving deltas: 100% (57590/57590), done.
```
Отлично! Теперь, когда у вас есть локальная копия Geth, вы можете скомпилировать исполняемый файл для вашей платформы.

#### Сборка Geth из исходного кода

Чтобы собрать Geth, перейдите в каталог, в который был загружен исходный код, и используйте команду make:

```
$ cd go-ethereum
$ make geth
```

Если все идет хорошо, вы увидите, как компилятор Go собирает каждый компонент, пока не создаст исполняемый файл geth:

```
build/env.sh go run build/ci.go install ./cmd/geth
>>> /usr/local/go/bin/go install -ldflags -X main.gitCommit=58a1e13e6dd7f52a1d...
github.com/ethereum/go-ethereum/common/hexutil
github.com/ethereum/go-ethereum/common/math
github.com/ethereum/go-ethereum/crypto/sha3
github.com/ethereum/go-ethereum/rlp
github.com/ethereum/go-ethereum/crypto/secp256k1
github.com/ethereum/go-ethereum/common
[...]
github.com/ethereum/go-ethereum/cmd/utils
github.com/ethereum/go-ethereum/cmd/geth
Done building.
Run "build/bin/geth" to launch geth.
$
```

Давайте убедимся, что geth работает, не запуская его на самом деле:

```
$ ./build/bin/geth version

Geth
Version: 1.9.11-unstable
Git Commit: 0b284f6c6cfc6df452ca23f9454ee16a6330cb8e
Git Commit Date: 20200123
Architecture: amd64
Protocol Versions: [64 63]
Go Version: go1.13.4
Operating System: linux
[...]
```

Ваша команда geth version может показать немного другую информацию, но вы должны увидеть отчет о версии, похожий на тот, что показан здесь.

В следующих разделах объясняется проблема с первоначальной синхронизацией блокчейна Ethereum.

## Первая синхронизация блокчейн на базе Ethereum
Традиционно при синхронизации блокчейна Ethereum ваш клиент загружает и проверяет каждый блок и каждую транзакцию с самого начала - то есть с генезисного блока.

Хотя таким образом можно полностью синхронизировать блокчейн, этот тип синхронизации занимает очень много времени и имеет высокие требования к ресурсам (ему потребуется гораздо больше оперативной памяти, и он займет очень много времени, если у вас нет быстрого хранилища).

В конце 2016 года многие блокчейны на базе Ethereum стали жертвами атак типа "отказ в обслуживании". Затронутые блокчейны будут медленно синхронизироваться при полной синхронизации.

Например, в Ethereum новый клиент будет быстро продвигаться вперед, пока не достигнет блока 2 283 397. Этот блок был добыт 18 сентября 2016 года и является началом DoS-атак. Начиная с этого блока и до блока 2 700 031 (26 ноября 2016 года), проверка транзакций становится чрезвычайно медленной, требующей много памяти и ввода-вывода. В результате время проверки превышает 1 минуту на блок. Ethereum внедрил серию обновлений, используя жесткие форки, чтобы устранить основные уязвимости, которые использовались в DoS-атаках. Эти обновления также очистили блокчейн, удалив около 20 миллионов пустых учетных записей, созданных в результате спам-транзакций.

Если вы синхронизируетесь с полной проверкой, ваш клиент будет работать медленнее и может потребоваться несколько дней, а возможно, и больше, чтобы проверить блоки, пострадавшие от DoS-атак.

К счастью, большинство клиентов Ethereum по умолчанию теперь выполняют "быструю" синхронизацию, которая пропускает полную валидацию транзакций, пока не синхронизируется с вершиной блокчейна, а затем возобновляет полную валидацию.

Geth выполняет быструю синхронизацию по умолчанию для Ethereum. Вам может потребоваться обратиться к специальным инструкциям для другой выбранной цепочки Ethereum.

Parity также выполняет быструю синхронизацию по умолчанию.

__Примечание:__ Geth может выполнять быструю синхронизацию только при запуске с пустой базой данных блоков. Если вы уже начали синхронизацию без быстрого режима, Geth не сможет переключиться. Быстрее удалить каталог данных блокчейна и начать быструю синхронизацию с самого начала, чем продолжать синхронизацию с полной проверкой. Будьте осторожны, чтобы не удалить кошельки при удалении данных блокчейна!

### Запуск Geth или Parity
Теперь, когда вы понимаете сложности "первой синхронизации", вы готовы запустить клиент Ethereum и синхронизировать блокчейн. Для Geth и Parity вы можете использовать опцию --help, чтобы увидеть все параметры конфигурации. Параметры по умолчанию обычно разумны и подходят для большинства случаев. Выберите, как настроить дополнительные параметры в соответствии с вашими потребностями, затем запустите Geth или Parity для синхронизации цепочки. Затем подождите...

__Совет:__ Синхронизация блокчейна Ethereum займет от полудня на очень быстрой системе с большим объемом оперативной памяти до нескольких дней на более медленной системе.

### Интерфейс JSON-RPC
Клиенты Ethereum предлагают интерфейс прикладного программирования и набор команд удаленного вызова процедур (RPC), которые закодированы в виде JavaScript Object Notation (JSON). В дальнейшем это будет называться API JSON-RPC. По сути, JSON-RPC API - это интерфейс, который позволяет нам писать программы, использующие клиент Ethereum в качестве шлюза к сети Ethereum и блокчейну.

Обычно интерфейс RPC предлагается в виде HTTP-сервиса на порту 8545. В целях безопасности он по умолчанию ограничен, чтобы принимать соединения только с localhost (IP-адрес вашего собственного компьютера, который равен 127.0.0.1).

Для доступа к JSON-RPC API можно использовать специализированную библиотеку (написанную на выбранном вами языке программирования), которая предоставляет "заглушки" вызовов функций, соответствующих каждой доступной RPC-команде, или вручную конструировать HTTP-запросы и отправлять/получать JSON-кодированные запросы. Вы даже можете использовать общий HTTP-клиент командной строки, например curl, для вызова интерфейса RPC. Давайте попробуем это сделать. Во-первых, убедитесь, что Geth запущен и работает, настроен с параметром --rpc для разрешения HTTP-доступа к интерфейсу RPC, затем переключитесь в новое окно терминала (например, с помощью Ctrl-Shift-N или Ctrl-Shift-T в существующем окне терминала), как показано здесь:


```
$ curl -X POST -H "Content-Type: application/json" --data \
  '{"jsonrpc":"2.0","method":"web3_clientVersion","params":[],"id":1}' \
  http://localhost:8545

{"jsonrpc":"2.0","id":1,
"result":"Geth/v1.9.11-unstable-0b284f6c-20200123/linux-amd64/go1.13.4"}
```

В этом примере мы используем curl для создания HTTP-соединения с адресом http://localhost:8545. Мы уже запустили geth, который предлагает JSON-RPC API в качестве HTTP-сервиса на порту 8545. Мы указываем curl использовать команду HTTP POST и идентифицировать содержимое как тип application/json. Наконец, мы передаем запрос в кодировке JSON в качестве компонента данных нашего HTTP-запроса. Большая часть нашей командной строки - это просто настройка curl для корректного установления HTTP-соединения. Интересной частью является сама команда JSON-RPC, которую мы передаем:

{"jsonrpc":"2.0","method":"web3_clientVersion","params":[],"id":1}
Запрос JSON-RPC отформатирован в соответствии со спецификацией JSON-RPC 2.0. Каждый запрос содержит четыре элемента:

__jsonrpc__
Версия протокола JSON-RPC. Это ДОЛЖНО быть именно "2.0".

__method__
Имя метода, который должен быть вызван.

__params__
Структурированное значение, содержащее значения параметров, которые будут использоваться во время вызова метода. Этот член МОЖЕТ быть опущен.

__id__
Идентификатор, установленный клиентом, который ДОЛЖЕН содержать значение String, Number или NULL, если он включен. Сервер ДОЛЖЕН ответить тем же значением в объекте ответа, если оно включено. Этот член используется для соотнесения контекста между двумя объектами.

__Совет:__ Параметр id используется в основном при выполнении нескольких запросов в одном вызове JSON-RPC, что называется пакетной обработкой. Пакетирование используется для того, чтобы избежать накладных расходов, связанных с созданием нового HTTP- и TCP-соединения для каждого запроса. В контексте Ethereum, например, мы бы использовали пакетную обработку, если бы хотели получить тысячи транзакций через одно HTTP-соединение. При пакетной обработке вы задаете отдельный идентификатор для каждого запроса, а затем сопоставляете его с идентификатором в каждом ответе сервера JSON-RPC. Самый простой способ реализовать это - вести счетчик и увеличивать его значение для каждого запроса.

Мы получаем следующий ответ:

```
{"jsonrpc":"2.0","id":1,
"result":"Geth/v1.9.11-unstable-0b284f6c-20200123/linux-amd64/go1.13.4"}
```

Это говорит нам о том, что API JSON-RPC обслуживается клиентом Geth версии 1.9.11.

Давайте попробуем кое-что более интересное. В следующем примере мы запросим у JSON-RPC API текущую цену на газ в вей:

```
$ curl -X POST -H "Content-Type: application/json" --data \
  '{"jsonrpc":"2.0","method":"eth_gasPrice","params":[],"id":4213}' \
  http://localhost:8545

{"jsonrpc":"2.0","id":4213,"result":"0x430e23400"}
```

Ответ, 0x430e23400, сообщает нам, что текущая цена на газ составляет 18 гвей (гигавей или миллиард вей). Если вы, как и мы, не думаете в шестнадцатеричной системе, вы можете перевести его в десятичную в командной строке с помощью небольшого bash-фу:

```
$ echo $((0x430e23400))

18000000000
```
Полный API JSON-RPC можно изучить на вики Ethereum.

#### Режим совместимости с Geth в Parity
У Parity есть специальный "режим совместимости с Geth", в котором он предлагает JSON-RPC API, идентичный тому, что предлагает Geth. Чтобы запустить Parity в этом режиме, используйте ключ --geth:

`$ parity --geth`

## Удаленные клиенты Ethereum

Удаленные клиенты предлагают лишь часть функций полного клиента. В них не хранится полный блокчейн Ethereum, поэтому они быстрее устанавливаются и требуют гораздо меньшего объема данных.

Эти клиенты обычно предоставляют возможность выполнять одно или несколько следующих действий:

- Управлять закрытыми ключами и адресами Ethereum в кошельке.
- Создавать, подписывать и транслировать транзакции.
- Взаимодействовать со смарт-контрактами, используя полезную нагрузку данных.
- Просматривать и взаимодействовать с DApps.
- Предлагать ссылки на внешние сервисы, такие как блокчейн-исследователи.
- Конвертировать единицы эфира и получать курсы обмена из внешних источников.
- Внедрение экземпляра web3 в веб-браузер в виде объекта JavaScript.
- Использовать экземпляр web3, предоставленный/введенный в браузер другим клиентом.
- Получить доступ к службам RPC на локальном или удаленном узле Ethereum.

Некоторые удаленные клиенты, например, мобильные (смартфонные) кошельки, предлагают только базовую функциональность кошелька. Другие удаленные клиенты являются полноценными DApp-браузерами. Удаленные клиенты обычно предлагают некоторые функции полноузлового клиента Ethereum без синхронизации локальной копии блокчейна Ethereum путем подключения к полноузловому клиенту, запущенному в другом месте, например, вами локально на вашей машине или на веб-сервере, или третьей стороной на их серверах.

Давайте рассмотрим некоторые из наиболее популярных удаленных клиентов и функции, которые они предлагают.

### Мобильные (смартфонные) кошельки
Все мобильные кошельки являются удаленными клиентами, поскольку смартфоны не обладают достаточными ресурсами для запуска полноценного клиента Ethereum. Легкие клиенты находятся в стадии разработки и не используются для Ethereum повсеместно. В случае с Parity, легкий клиент помечен как "экспериментальный" и может быть использован путем запуска parity с опцией --light.

Популярные мобильные кошельки включают следующие (мы приводим их только в качестве примера; это не является подтверждением или указанием на безопасность или функциональность этих кошельков):

#### Jaxx(https://jaxx.io/)
Мультивалютный мобильный кошелек на основе мнемонических семян BIP-39 с поддержкой Bitcoin, Litecoin, Ethereum, Ethereum Classic, ZCash, различных токенов ERC20 и многих других валют. Jaxx доступен на Android и iOS, в виде подключаемого к браузеру кошелька, а также в виде настольного кошелька для различных операционных систем.

#### Status(https://status.im/)
Мобильный кошелек и браузер DApp с поддержкой различных токенов и популярных DApp. Доступен для iOS и Android.

#### Trust Wallet (https://trustwalletapp.com/)
Мобильный мультивалютный кошелек, поддерживающий Ethereum и Ethereum Classic, а также токены ERC20 и ERC223. Trust Wallet доступен для iOS и Android.

#### Cipher Browser (https://www.cipherbrowser.com/)
Полнофункциональный мобильный DApp-браузер и кошелек с поддержкой Ethereum, позволяющий интегрироваться с приложениями и токенами Ethereum. Доступен для iOS и Android.

#### Браузерные кошельки
Различные кошельки и браузеры DApp доступны в виде плагинов или расширений веб-браузеров, таких как Chrome и Firefox. Это удаленные клиенты, которые работают внутри вашего браузера.

Некоторые из наиболее популярных - MetaMask, Jaxx, MyEtherWallet и MyCrypto.

##### MetaMask
MetaMask, представленный в [intro_chapter], - это универсальный браузерный кошелек, RPC-клиент и проводник основных контрактов. Он доступен в Chrome, Firefox, Opera и Brave Browser.

В отличие от других браузерных кошельков, MetaMask внедряет экземпляр web3 в JavaScript-контекст браузера, действуя как RPC-клиент, который подключается к различным блокчейнам Ethereum (mainnet, Ropsten testnet, Kovan testnet, локальный RPC-узел и т.д.). Возможность внедрять экземпляр web3 и выступать в качестве шлюза для внешних RPC-сервисов делает MetaMask очень мощным инструментом как для разработчиков, так и для пользователей. Например, его можно комбинировать с MyEtherWallet или MyCrypto, выступая в качестве web3-провайдера и RPC-шлюза для этих инструментов.

##### Jaxx
Jaxx, который был представлен в предыдущем разделе как мобильный кошелек, также доступен как расширение для Chrome и Firefox и как кошелек для настольных компьютеров.

##### MyEtherWallet (MEW)
MyEtherWallet - это браузерный удаленный клиент на JavaScript, который предлагает:

- мост к популярным аппаратным кошелькам, таким как Trezor и Ledger.
- web3-интерфейс, который может подключаться к экземпляру web3, введенному другим клиентом (например, MetaMask).
- RPC-клиент, который может подключаться к полному клиенту Ethereum
- Базовый интерфейс, который может взаимодействовать со смарт-контрактами, учитывая адрес контракта и бинарный интерфейс приложения (ABI).
- Мобильное приложение MEWConnect, позволяющее использовать совместимое устройство Android или iOS для хранения средств, аналогично аппаратному кошельку.
- Программный кошелек, работающий на JavaScript

__Предупреждение:__
Вы должны быть очень осторожны при доступе к MyEtherWallet и другим браузерным JavaScript-кошелькам, поскольку они являются частой мишенью для фишинга. Всегда используйте закладку, а не поисковую систему или ссылку для доступа к нужному URL-адресу.

##### MyCrypto
В начале 2018 года проект MyEtherWallet разделился на две конкурирующие реализации, управляемые двумя независимыми командами разработчиков: "форк", как это называется в разработке с открытым исходным кодом. Два проекта называются MyEtherWallet (оригинальный брендинг) и MyCrypto. MyCrypto предлагает практически идентичные функции, что и MyEtherWallet, но вместо использования MEWConnect он предлагает подключение к мобильному приложению Parity Signer. Как и MEWConnect, Parity Signer хранит ключи на телефоне и взаимодействует с MyCrypto аналогично аппаратному кошельку.

##### Mist (устарел)
Mist был первым браузером с поддержкой Ethereum, созданным Ethereum Foundation. Он содержал браузерный кошелек, который был первой реализацией стандарта токенов ERC20 (Фабиан Фогельстеллер, автор ERC20, также был главным разработчиком Mist). Mist также был первым кошельком, который ввел контрольную сумму camelCase (EIP-55). По состоянию на март 2019 года Mist был устаревшим и больше не должен использоваться.

## Выводы
В этой главе мы изучили клиенты Ethereum. Вы скачали, установили и синхронизировали клиент, став участником сети Ethereum и внеся свой вклад в здоровье и стабильность системы, реплицируя блокчейн на своем компьютере.