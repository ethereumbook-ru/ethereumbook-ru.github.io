<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">

    <title>hexo-theme-doc-seed |  </title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    

    <!-- fonts -->
    <link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700" rel="stylesheet">
    <link href="//fonts.googleapis.com/css?family=Ubuntu:300,400,500,600,700" rel="stylesheet">

    <!-- stylesheets -->
    <link rel="stylesheet" href="/style/doc.css">

    <!-- favicon -->
    <link rel="icon" href="/images/favicon.ico">

    

  </head>
  <body>

   <script>window.__INITIAL_STATE__ = {"page":{"path":"book/ens.html","title":""},"data":{"navigation":{"logo":{"text":"Mastering Ethereum. Русский перевод","type":"link","path":"index.html"},"main":[{"text":"Оглавление","type":"label"},{"text":"Предисловие","type":"link","path":"book/preface.html"},{"text":"Глоссарий","type":"link","path":"book/glossary.html"},{"text":"Что такое Ethereum","type":"link","path":"book/what-is.html"},{"text":"Введение","type":"link","path":"book/intro.html"},{"text":"Клиенты Ethereum","type":"link","path":"book/clients.html"},{"text":"Тестнет Ethereum","type":"link","path":"book/ethereum-testnets.html"},{"text":"Ключи и Адреса","type":"link","path":"book/keys-addresses.html"},{"text":"Кошельки","type":"link","path":"book/wallets.html"},{"text":"Транзакции","type":"link","path":"book/transactions.html"},{"text":"Смарт контракты","type":"link","path":"book/smart-contracts.html"},{"text":"Инструменты разработчика и фреймворки","type":"link","path":"book/dev-tools.html"},{"text":"Токены","type":"link","path":"book/tokens.html"},{"text":"DApps","type":"link","path":"book/dapps.html"},{"text":"Ораклы","type":"link","path":"book/oracles.html"},{"text":"Accounting & Gas","type":"link","path":"book/gas.html"},{"text":"EVM","type":"link","path":"book/evm.html"},{"text":"Консенсус","type":"link","path":"book/consensus.html"},{"text":"Vyper","type":"link","path":"book/vyper.html"},{"text":"Протокол DevP2P","type":"link","path":"book/devp2p-protocol.html"},{"text":"Стандарты Ethereum (EIPs/ERCs)","type":"link","path":"book/standards-eip-erc.html"},{"text":"История форков (DAO/ETC)","type":"link","path":"book/forks-history.html"},{"text":"Дополнительно","type":"label"},{"text":"Комментировать на Github","type":"link","path":"https://github.com/ethereumbook-ru/ethereumbook-ru.github.io/issues/new"}]}},"config":{"timezone":"UTC","root":"/","time_format":"HH:mm:ss","theme":"../node_modules/hexo-theme-doc","theme_config":{"swagger_ui":{"version":2,"permalinks":true,"api_explorer":true,"download":"Download specification","show_extensions":false,"deep_linking":true,"display_operation_id":false,"doc_expansion":"none"},"search":{"skip":false,"background":false,"route":"/lunr.json"},"favicon":"images/favicon.ico"}}}</script>

    <div id="react-navigation-root"><div class="doc-navigation" data-reactroot=""><nav class="doc-navbar"><a href="/index.html" class="doc-navbar__logo"><img src="/images/logo.png" class="doc-navbar__logo__img"/><span class="doc-navbar__logo__text">Mastering Ethereum. Русский перевод</span></a><i class="dc-icon dc-icon--close dc-icon--interactive doc-sidebar-close doc-navbar__sidebar-close doc-navbar__sidebar-close--desktop"></i><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-navbar__sidebar-toggle"></i></nav><nav class="doc-sidebar"><div class="doc-sidebar__vertical-menu"><i class="dc-icon dc-icon--menu dc-icon--interactive doc-sidebar-toggle doc-sidebar-toggle--primary doc-sidebar__vertical-menu__item"></i><i class="dc-icon dc-icon--search dc-icon--interactive doc-sidebar__vertical-menu__item doc-sidebar__vertical-menu__item--primary"></i></div><div class="doc-sidebar-content"><div class="doc-sidebar__search-form"></div><ul class="doc-sidebar-list"></ul></div></nav></div></div>
    <div class="doc-content">
  <div class="dc-page">
    <div class="dc-card">
      <div id="react-search-results-root"></div>
      <div id="page-content" class="doc-formatting">
        <p>== Ethereum Name Service (ENS)</p>
<p>You can design the best smart contract in the world, but if you don’t provide a good interface for users, they won’t be able to access it.</p>
<p>Contracts on the blockchain can be considered the backend of your application, and you can write the front-end in any language or platform you feel comfortable.</p>
<p>Most of the apps you’ll read about on this book currently use a traditional server model to serve that front-end, but if you want to truly decentralize your application, you can also use decentralized hosting services like bit torrent, <em>Swarm</em> or <em>IPFS</em> to also host the files required for the <em>front-end</em>.</p>
<p>In a traditional server model of the web, you access content by describing the address where you can find the content.<br>For instance <em>91.198.174.192</em> is the IP address of Wikipedia. That number has no information on what sort of content you will find, only the address of the computers that will serve you wikipedia’s content.</p>
<p>Content-addressing systems are different in that their address reflect the content itself not its location.</p>
<p>For instance, the url <em>QmfXeApFP1mCrMTT1JX5XLtUvLxS5eNsegqDpBYUZPhXEQ</em> actually describes an image that you can download from any computer on the IPFS network.</p>
<p>Different standards, like <em>IPFS</em> or <em>Swarm</em> will have different hashes, but <em>they all describe the content not the address itself</em>.<br>This allows <em>more flexibility and decentralization</em> because as long as a single node in your network has a copy of that image (or is connected to a node that has a copy of it), they can access it.</p>
<p>This process allows accessing any files that will make up your interface, html, javascript, css, images, etc in a decentralized manner, but has a huge drawback: urls are not very human friendly.<br>They consist of large mumbles of letters and numbers, which are neither memorable or easy to type.</p>
<p>On the traditional IP-based internet, this was solved by <em>Domain Naming system (DNS)</em>, an hierarchical system ultimately centralized on <em>ICANN</em>, a US-based organization that controls the distribution of top level domains, like <em>.com</em> or <em>.org</em>.</p>
<p>On the blockchain an attempt to solve the same problem but in a decentralized manner is the <em>Ethereum Naming System (ENS)</em>.</p>
<p>Another advantadge of a naming system is that it can also be used as a aliases for receiving funds or identifiers.</p>
<p>As an example, the <em>Ethereum Foundation</em> donation contract address is <em>0xfB6916095ca1df60bB79Ce92cE3Ea74c37c5d359</em> or, in a wallet that supports ENS, it’s simply <em>ethereum.eth</em>.</p>
<p>=== Name resolution services</p>
<ul>
<li>What is a name resolution service?</li>
<li>Why another one?</li>
<li>Why are they needed (addresses, contracts, swarm objects, etc.)</li>
<li>Benefits (security, disambiguation, redirection/upgrade, readability/user experience)</li>
<li>Concerns about squatting, trademarks, dispute resolution</li>
</ul>
<p>=== History of Ethereum name services</p>
<p>Name registrations is the first non-currency application of blockchains, being pioneered by <em>Namecoin</em>.<br>The ethereum whitepaper contains as one of their example aplications, a two lines <em>namecoin-like</em> registration system.</p>
<p>The early releases of geth and CPP client had a standard default <em>namereg</em> contract (<em>not used anymore</em>) and many proposals and <em>ERCs</em> have existed since the beginning, but it was not before <em>Nick Johnson</em> started working for Ethereum Foundation in 2016 and took the project under his wing that work on a serious registrar started.</p>
<p>ENS was launched on Star Wars day, May 4, 2017 (after a failed attempt of launching it on Pie Day, march 15) and it was open for registrations.</p>
<p>=== The ENS specification</p>
<p>ENS is specified mainly in three <em>Ethereum Improvement Proposals (EIP)</em>, namely <em>RC137</em> which <em>specifies the basic</em> ENS functioning, <em>ERC162</em> the <em>auction</em> system for the <em>.eth</em> root and <em>ERC181</em> for <em>reverse registration</em> of addresses.</p>
<p>ENS follows a <em>sandwich</em> design philosophy: a very simple layer on the bottom, followed by layers of more complex but <em>replaceable code</em>, followed with a very <em>simple top layer</em> that <em>keeps all the funds in separate individual accounts</em>.</p>
<p>=== Bottom of the sandwich: Name Owners and resolvers</p>
<p>The base layer of the sandwich is a cleverly simple (less than 50 lines of code) contract defined by <em>ERC137</em> that basically only allows owners of names to <em>set information about their names and to create subnodes</em> (subdomains).</p>
<p>The core of this simplicity is the identifier mechanism for names, called <em>Namehash</em>.</p>
<p>The ENS operates on <em>nodes</em> instead of <em>human-readable</em> names; a human readable name is converted to a node using the <em>namehash recursive algorithm</em>.</p>
<p>==== Namehash algorithm</p>
<p>Namehash actually is a recursive algorithm that convert <em>any name</em> into an <em>identifier hash</em> of that name.</p>
<p>Recursive here means, we solve the <em>problem</em> solving a <em>subproblem</em> that is a <em>smaller instance</em> of the <em>same problem</em>, and then <em>use the solution to that smaller instance</em> to solve the <em>original problem</em>.</p>
<p>Let’s see an example;</p>
<p>….<br>Root Node:  <code>keccak(0x0000000000000000000000000000000000000000000000000000000000000000)</code><br>“.eth” node: <code>keccak( (Root Node) + keccak(&#39;eth&#39;))</code><br>“example.eth” node: <code>keccak( (&#39;.eth&#39; node) + keccak(&#39;example&#39;))</code><br>“subdomain.example.eth” node: <code>keccak( (&#39;example.eth&#39; node) + keccak(&#39;subdomain&#39;))</code><br>….</p>
<p>And so recursively.</p>
<p>This algorithm recursively <em>hashes</em> components of the name, producing a <em>unique</em>, <em>fixed-length</em> string for any valid input domain.<br>The <em>output</em> of the namehash algorithm is referred to as a <em>node</em>.</p>
<p>Let’s see more examples of this algorithm.</p>
<p>In a more concise way we could define namehash function as follows;</p>
<p>….<br>namehash([]) = 0x0000000000000000000000000000000000000000000000000000000000000000<br>namehash([label, …]) = keccak256(namehash(…), keccak256(label))<br>….</p>
<p>Or in Python;</p>
<p>….<br>def namehash(name):<br>  if name == ‘’:<br>    return ‘\0’ * 32<br>  else:<br>    label, _, remainder = name.partition(‘.’)<br>    return sha3(namehash(remainder) + sha3(label))<br>….</p>
<p>Thus, <em>mastering-ethereum.eth</em> will be processed as follows;</p>
<p>….<br>node = ‘\0’ * 32<br>node = sha3(node + sha3(‘eth’))<br>node = sha3(node + sha3(‘mastering-ethereum’))<br>….</p>
<p>You could ask yourself if after for instance, <em>subdomain.example.eth</em>, there could be a <em>sub.subdomain.example.eth</em>, then a <em>sub.sub.subdomain.example.eth</em> and so on. Is there really no limit to this recursion?</p>
<p>Because the <em>namehash</em> procedure depends only on the name itself, this can be <em>precomputed</em> and inserted into a contract, removing the need for string manipulation, and permitting <em>O(1) lookup</em> of ENS records regardless of the number of components in the raw name.</p>
<p>By <em>O(1)</em>, here we mean that it takes a constant time, like <em>14 nanoseconds</em>, or <em>three minutes</em> <em>no matter the amount</em> of data in the set.</p>
<p>The only functions on the base layer are those that enable a node owner to set information about their own node (specifically the resolver, time to live or transferring the ownership) and to create owners of new subnodes.</p>
<p>==== How to choose a valid name<br>Names consist of a series of <em>dot-separated labels</em>.</p>
<p>Although <em>upper and lower case</em> letters in principle they are allowed, all label should follow a <em>UTS46</em> normalisation process that case-folds labels before hashing them, so names with different case but identical spelling will end up with the <em>same namehash</em>.</p>
<p>You could use labels and domains of <em>any length</em>, but for the sake of compatibility with legacy <em>DNS</em>, the following is recommended;</p>
<ul>
<li>Labels be restricted to <em>no more than 64 characters</em> each.</li>
<li>Complete ENS names to <em>no more than 255 characters</em>.</li>
<li>Labels <em>do not start or end</em> with <em>hyphens</em>, or <em>start</em> with <em>digits</em>.</li>
</ul>
<p>==== Rootnode ownership</p>
<p>One of the results of this hierarchical system is that it relies on the owners of the <em>Rootnode</em> that are able to create top level domains.</p>
<p>While the eventual goal is to move this into some sort of decentralized decision making process for new top level domains, right now the rootnode is a <em>4 out of 7 multisig</em>, held by people in different countries (<em>built as a reflection of the seven keyholders of the DNS system</em>).<br>As a result, <em>a majority of at least 4 of the 7 keyholders</em> is required <em>to effect any change</em>.</p>
<p>Currently the purpose and goal of these keyholders is to work in consensus with the community to:</p>
<ul>
<li>Migrate and upgrade the temporary ownership of the <em>.eth TLD</em> (<em>Top Level Domain</em>) to a <em>more permanent contract</em> once the system is evaluated.</li>
<li>Allow <em>adding new TLDs</em>, if the community agrees that such is ever needed.</li>
<li><em>Migrate the ownership of the root multisig</em> in a more decentralized contract, when such system is agreed upon, tested and implemented.</li>
<li>To serve as <em>a last resort</em> way to deal with any <em>bugs or vulnerability</em> on the top level registries.</li>
</ul>
<p>==== Resolvers</p>
<p>The basic ENS contract <em>doesn’t allow owners</em> of <em>adding any metadata</em> to contracts, that is the job of the <em>Resolver Contracts</em>.</p>
<p>The purpose is to allow more flexibility by allowing users to <em>create custom contracts</em> that can answer any questions about the name in itself, like <em>“what’s the swarm address associated with this app?”</em>, <em>“what is the ethereum address that receives payments in ether and tokens?”</em>, <em>“what’s the hash of the app, in order to verify its integrity?”</em>.</p>
<p>=== Middle layer: the “.eth” nodes</p>
<p>At the moment, the only top level domain that is uniquely registrable in a smart contract is <em>.eth</em>.</p>
<p>There’s work on enabling <em>traditional DNS domain owners</em> to claim <em>ENS ownership</em>.<br>While in theory this could work for <em>.com</em> the only domain that this has been <a href="https://medium.com/the-ethereum-name-service/how-to-claim-your-dns-domain-on-ens-e600ef2d92ca" target="_blank" rel="noopener">implemented is also for <em>.xyz</em> but in Testnet</a>.</p>
<p>The way Eth domains are distributed are via an auction system. There is no special <em>reserved lists</em> or <em>exclusive priorities</em>, and the only way to acquire a name is to use the same system as everyone.</p>
<p>That is a much more complex bit of code (over 500 lines of code), and where most of the bugs and tests on the development phase where here.<br>But it’s also replaceable and upgradeable (without risks to the funds – more on that later).</p>
<p>==== Vickrey Auctions</p>
<p>The way names are distributed is via a <em>Vickrey Auction</em>, a <em>blind</em> auction that attempts to find the <em>bidder</em> with the <em>higher</em> expected utility for the name, but without exagerating the value.<br>Since there are no profits gathered from the auctions, there’s no incentive to maximize it.</p>
<p>In a traditional Vickrey auction, every bidder submits a <em>sealed</em> bid, and all of them are <em>revealed during the reveal period</em>, at which point the person with the <em>highest bid</em> wins the auction, but only pays <em>the second higher price</em>.</p>
<p>Therefore bidders are incentivized in putting down their theoretical maximum utility value for a domain, since increasing it increases the chance they will win but does not affect the price they will eventually pay: they only need to pay enough to outbid the second higher bidder.</p>
<p>On a blockchain, some changes are required;</p>
<ul>
<li>Since you don’t have everyone on the same room legally binding them to their promises, then bidders MUST to lock up a value equal or higher than their bid beforehand, to guarantee the bid is valid.</li>
<li>Because you can’t hide secrets on a blockchain, bidders MUST execute at least two transactions, a commit and then a reveal process, in order to hide the original value and name they bid on.</li>
<li>Since you can’t reveal all bids on the same time on a decentralized manner bidders MUST reveal their own bids themselves or be punished by losing their funds if they don’t.<br>If such punishment did not exist, one could make multiple bids in many price points and choose to only reveal a few strategically ones, therefore turning a sealed-bid auction in a traditional increasing price auction.</li>
</ul>
<p>Therefore the auction process is a four step process;</p>
<ol>
<li><p>Start the auction (<em>or auctions</em>). This is a required step to broadcast the intent to register a name.<br>This creates all auction deadlines. The <em>names are hashed</em>, so that <em>only those who have the name in their dictionary will know which auction was opened</em>. This allows <em>some privacy</em>, specially if <em>you are creating a new project</em> and don’t want to share details about it.<br>You can open multiple “dummy” hashes at the same time, so if someone is following you, they cannot simply bid on all auctions you open.</p>
</li>
<li><p>Make a <em>sealed bid</em>: you must do this before the bidding deadline, by tying up a given amount of ether to a hash of a <em>secret message</em> (<em>containing, among others, the hash of the name, the actual amount of the bid, and a salt</em>).<br>You can lock up more ether than you are actually bidding in order to mask the real evaluate.</p>
</li>
<li><p><em>Reveal the bid</em>: during the reveal period, you MUST make a transaction that reveals the bid, which will then calculate the higher bidder, the second higher bid and send extra ether back to owners.<br>Every time the bid is revealed the <em>current winner is recalculated</em>, therefore the last one to be set before the revealing deadline expires, becomes the owners.</p>
</li>
<li><p>Clean up after: if you are the owner, you can <em>finalize</em> the auction in order to get back the difference between <em>your bid and the second higher one</em>.<br>If you forgot to reveal you can make a late reveal and recover a small amount of the original value.</p>
</li>
</ol>
<p>==== Top layer of the sandwich: the Deeds</p>
<p>The last piece of the sandwich, the top bun so to speak is yet another super simple contract with a single purpose: to <em>hold the funds</em>.</p>
<p>When you <em>win</em> a name, the funds are not actually sent anywhere, but are <em>just locked up</em> for the period you want to hold the name (<em>minimum of a year</em>).<br>This works like a <em>guarantee</em> <em>buy-back model</em>, where <em>if the owner does not want the name anymore they can sell it back to the system</em> and get their ether back (making so that the cost of holding the name was the opportunity cost of doing anything with a better return than 0% interest).</p>
<p>But of course, having a single contract hold millions of dollars in ether has proven to be very risky so instead ENS solves that by creating a <em>Deed Contract</em> for each <em>new name</em>.<br>The <em>Deed Contract</em> is a very simple code (about 50 lines of code) and it only allows the funds to be transferred back to a single account (<em>the deed owner</em>) and to be called by a single entity (<em>the registrar contract</em>).<br>This approach drastically reduces the surface of attack where bugs can put the funds at risk.</p>
<p>=== Registering a name<br>.ENS timeline for registration<br>image::images/ens-flow.png[]</p>
<p>////<br>Image with permission from Chris Remus, Nick Johnson and Alex Van de Sande, via article by Chris Remus<br>////</p>
<p>=== Resolving a name</p>
<p>In ENS, resolving a name, is a <em>two-step</em> process.</p>
<p>First, <em>the ENS registry is called</em> with the name <em>to resolve</em> after hashing it.</p>
<p>If the record exists, <em>the registry returns the address</em> of its resolver.</p>
<p>Then, the <em>resolver is called, using the method appropriate to the resource being requested</em>. The resolver then returns the desired result.</p>
<p>=== Setting an ENS name resolver</p>
<p>==== Types of resolvers</p>
<p>==== Address resolver</p>
<p>==== Smart contract resolver</p>
<p>==== Swarm object resolver</p>
<p>=== ENS subdomains</p>
<p>==== Creating a subdomains</p>
<p>=== ENS secondary markets</p>
<p>==== Buying and selling names</p>
<p>==== Renting a name</p>
<p>=== Conclusion</p>
<p>Links:</p>
<p><a href="https://ens.domains/" target="_blank" rel="noopener">https://ens.domains/</a></p>
<p><a href="https://mycrypto.com/#ens" target="_blank" rel="noopener">https://mycrypto.com/#ens</a></p>
<p><a href="https://manager.ens.domains/" target="_blank" rel="noopener">https://manager.ens.domains/</a></p>
<p><a href="https://registrar.ens.domains/" target="_blank" rel="noopener">https://registrar.ens.domains/</a></p>
<p><a href="https://github.com/ethereum/ens/" target="_blank" rel="noopener">https://github.com/ethereum/ens/</a></p>
<p><a href="https://docs.ens.domains/" target="_blank" rel="noopener">https://docs.ens.domains/</a></p>

        <div id="react-support-footer-root"></div>
      </div>
    </div>
  </div>
</div>

    


    

    <!-- js vendors -->
    <script src="//code.jquery.com/jquery-3.2.1.min.js" crossorigin="anonymous"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/lunr.js/2.1.0/lunr.min.js"></script>

    <!-- js source  -->
    <script src="/script/doc.js"></script>

    

  </body>
</html>
