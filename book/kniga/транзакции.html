<!DOCTYPE HTML>
<html lang="ru" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Транзакции - Осваиваем Ethereum - Mastering Ethereum</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Руководство по Ethereum и разработке смарт-контрактов">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../1_предисловие.html">Предисловие</a></li><li class="chapter-item expanded affix "><a href="../2_глоссарий.html">Глоссарий</a></li><li class="chapter-item expanded affix "><li class="part-title">Книга</li><li class="chapter-item expanded "><a href="../kniga/что_такое_ethereum.html"><strong aria-hidden="true">1.</strong> Что такое Ethereum?</a></li><li class="chapter-item expanded "><a href="../kniga/введение.html"><strong aria-hidden="true">2.</strong> Введение</a></li><li class="chapter-item expanded "><a href="../kniga/клиенты.html"><strong aria-hidden="true">3.</strong> Клиенты</a></li><li class="chapter-item expanded "><a href="../kniga/ключи_и_адреса.html"><strong aria-hidden="true">4.</strong> Ключи и адреса</a></li><li class="chapter-item expanded "><a href="../kniga/кошельки.html"><strong aria-hidden="true">5.</strong> Кошельки</a></li><li class="chapter-item expanded "><a href="../kniga/транзакции.html" class="active"><strong aria-hidden="true">6.</strong> Транзакции</a></li><li class="chapter-item expanded "><a href="../kniga/смарт_контракты_на_solidity.html"><strong aria-hidden="true">7.</strong> Смарт-контракты на Solidity</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.</strong> Смарт-контракты на Vyper</div></li><li class="chapter-item expanded "><a href="../kniga/безопаность_смарт_контрактов.html"><strong aria-hidden="true">9.</strong> Безопаность смарт-контрактов</a></li><li class="chapter-item expanded "><a href="../kniga/токены.html"><strong aria-hidden="true">10.</strong> Токены</a></li><li class="chapter-item expanded "><a href="../kniga/оракулы.html"><strong aria-hidden="true">11.</strong> Оракулы</a></li><li class="chapter-item expanded "><a href="../kniga/децентрализованные_приложения.html"><strong aria-hidden="true">12.</strong> Децентрализованные приложения</a></li><li class="chapter-item expanded "><a href="../kniga/виртуальная_машина_ethereum.html"><strong aria-hidden="true">13.</strong> Виртуальная машина Ethereum</a></li><li class="chapter-item expanded "><a href="../kniga/консенсус.html"><strong aria-hidden="true">14.</strong> Консенсус</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">15.</strong> Доп 1. История ветвлений</div></li><li class="chapter-item expanded "><a href="../kniga/дополнение_2_стандарты_eip_erc.html"><strong aria-hidden="true">16.</strong> Доп 2. Стандарты EIP, ERC</a></li><li class="chapter-item expanded "><a href="../kniga/дополнение_3_коды_evm_и_gas.html"><strong aria-hidden="true">17.</strong> Доп 3. Коды EVM и газ</a></li><li class="chapter-item expanded "><a href="../kniga/дополнение_4_инструменты_solidity_разработчика.html"><strong aria-hidden="true">18.</strong> Доп 4. Инструменты разработчика</a></li><li class="chapter-item expanded "><a href="../kniga//дополнение_5_руководство_по_web3js.html"><strong aria-hidden="true">19.</strong> Доп 5. Руководство по web3js</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><a href="../support.html">Поддержка проекта</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Осваиваем Ethereum - Mastering Ethereum</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="Транзакции"><a class="header" href="#Транзакции">Транзакции</a></h1>
<p>Транзакции - это подписанные сообщения, созданные аккаунтом с внешним управлением (EOA), переданные сетью Ethereum и записанные в блокчейн Ethereum. За этим базовым определением скрывается множество удивительных и захватывающих деталей. Другой способ взглянуть на транзакции заключается в том, что они - единственное, что может вызвать изменение состояния или привести к исполнению контракта в EVM. </p>
<p>Ethereum - это глобальная машина состояний, а транзакции - это то, что заставляет эту машину состояний &quot;тикать&quot;, изменяя ее состояние. Контракты не выполняются сами по себе. Ethereum не работает автономно. Все начинается с транзакции.</p>
<p>В этой главе мы разберем транзакции, покажем, как они работают, и рассмотрим детали. Обратите внимание, что большая часть этой главы адресована тем, кто заинтересован в работе с собственными транзакциями на низком уровне, возможно, потому что пишет децентрализованное приложение.</p>
<h2 id="Структура-транзакции"><a class="header" href="#Структура-транзакции">Структура транзакции</a></h2>
<p>Сначала давайте рассмотрим базовую структуру транзакции, как она сериализуется и передается в сети Ethereum. Каждый клиент и приложение, получающее сериализованную транзакцию, будет хранить ее в памяти, используя свою собственную внутреннюю структуру данных, возможно, дополненную метаданными, которых нет в самой сериализованной транзакции. Сетевая сериализация - это единственная стандартная форма транзакции.</p>
<p>Транзакция - это сериализованное двоичное сообщение, содержащее следующие данные:</p>
<h3 id="nonce"><a class="header" href="#nonce">Nonce</a></h3>
<p>Порядковый номер, выдаваемый отправляющим EOA, используемый для предотвращения повторного воспроизведения сообщения.</p>
<h3 id="gas-price"><a class="header" href="#gas-price">Gas price</a></h3>
<p>Количество ether (в wei), которое отправитель готов заплатить за каждую единицу газа</p>
<h3 id="gas-limit"><a class="header" href="#gas-limit">Gas limit</a></h3>
<p>Максимальное количество газа, которое отправитель готов использовать для данной транзакции</p>
<h3 id="recipient"><a class="header" href="#recipient">Recipient</a></h3>
<p>Адрес назначения в Ethereum</p>
<h3 id="value"><a class="header" href="#value">Value</a></h3>
<p>Количество ether (в wei) для отправки в пункт назначения</p>
<h3 id="data"><a class="header" href="#data">Data</a></h3>
<p>Полезная нагрузка в виде двоичных данных переменной длины</p>
<h3 id="v-r-s"><a class="header" href="#v-r-s">v, r, s</a></h3>
<p>Три компонента цифровой подписи ECDSA создающего EOA</p>
<p>Структура сообщения транзакции сериализуется с помощью схемы кодирования <em>Recursive Length Prefix (RLP)</em>, которая была создана специально для простой, байтовой сериализации данных в Ethereum. Все числа в Ethereum кодируются как большие целые числа, длина которых кратна 8 битам.</p>
<p>Обратите внимание, что метки полей (<strong>to</strong>, <strong>gas_limit</strong> и т.д.) показаны здесь для наглядности, но не являются частью сериализованных данных транзакции, которые содержат значения полей в RLP-кодировке. В целом, RLP не содержит никаких разделителей или меток полей. Префикс длины RLP используется для определения длины каждого поля. Все, что превышает определенную длину, относится к следующему полю в структуре.</p>
<p>Хотя это фактическая структура передаваемой транзакции, большинство внутренних представлений и визуализаций пользовательского интерфейса украшают ее дополнительной информацией, полученной из транзакции или из блокчейна.</p>
<p>Например, вы можете заметить, что в адресе, идентифицирующем EOA отправителя, нет данных &quot;from&quot;. Это потому, что открытый ключ EOA может быть получен из компонентов <strong>v,r,s</strong> подписи ECDSA. Адрес, в свою очередь, может быть получен из открытого ключа. Когда вы видите транзакцию с полем &quot;<strong>from</strong>&quot;, это поле было добавлено программным обеспечением, используемым для визуализации транзакции. Другие метаданные, часто добавляемые к транзакции клиентским программным обеспечением, включают номер блока (когда он добыт и включен в блокчейн) и идентификатор транзакции (вычисленный хэш). Опять же, эти данные получены из транзакции и не являются частью самого сообщения о транзакции.</p>
<h2 id="nonce-транзакции"><a class="header" href="#nonce-транзакции">Nonce транзакции</a></h2>
<p>Nonce является одним из наиболее важных и наименее понятных компонентов транзакции. Определение в Желтой книге (см. [ссылки]) гласит:</p>
<p>nonce: Скалярное значение, равное количеству транзакций, отправленных с этого адреса, или, в случае счетов с ассоциированным кодом, количеству контрактов-созданий, выполненных этим счетом.</p>
<p>Строго говоря, nonce является атрибутом адреса отправителя; то есть он имеет значение только в контексте адреса отправителя. Однако nonce не хранится в явном виде как часть состояния счета в блокчейне. Вместо этого он вычисляется динамически, путем подсчета количества подтвержденных транзакций, которые исходили от адреса.</p>
<p>Есть два сценария, в которых существование nonce для подсчета транзакций важно: удобство использования, когда транзакции включаются в порядок создания, и жизненно важная функция защиты от дублирования транзакций. Давайте рассмотрим пример каждого из этих сценариев:</p>
<ol>
<li>
<p>Представьте, что вы хотите совершить две транзакции. Вам нужно совершить важный платеж в размере 6 ether, а также другой платеж в размере 8 ether. Вы подписываете и отправляете сначала транзакцию на 6 ether, потому что она важнее, а затем подписываете и транслируете вторую, на 8 ether. К сожалению, вы упустили из виду тот факт, что на вашем счету всего 10 ether, поэтому сеть не может принять обе транзакции: одна из них не пройдет. Поскольку вы отправили сначала более важную транзакцию на 6 ether, вы, понятно, ожидаете, что она пройдет, а транзакция на 8 ether будет отклонена. Однако в такой децентрализованной системе, как Ethereum, узлы могут получать транзакции в любом порядке; нет никакой гарантии, что конкретный узел получит одну транзакцию раньше другой. Поэтому почти наверняка некоторые узлы получат сначала транзакцию на 6 ether, а другие - на 8 ether. Если не включать nonce, то будет случайным, какая транзакция будет принята, а какая отклонена. Однако с включенным nonce первая отправленная вами транзакция будет иметь nonce, допустим, 3, в то время как транзакция на 8 ether будет иметь следующее значение nonce (т.е. 4). Таким образом, эта транзакция будет игнорироваться до тех пор, пока не будут обработаны транзакции с кодами от 0 до 3, даже если она будет получена первой.</p>
</li>
<li>
<p>Теперь представьте, что у вас есть счет со 100 ether. Вы находите в Интернете человека, который принимает оплату в ether за Алатырь-камень, который вы очень хотите купить. Вы посылаете ему 2 ether, и он высылает вам Алатырь-камень. Прекрасно. Чтобы осуществить этот платеж в 2 ether, вы подписали транзакцию, отправив 2 ether со своего счета на его счет, а затем передали ее в сеть Ethereum для проверки и включения в блокчейн. Теперь, без значения nonce в транзакции, вторая транзакция, отправляющая 2 ether на тот же адрес во второй раз, будет выглядеть точно так же, как и первая. Это означает, что любой, кто увидит вашу транзакцию в сети Ethereum (а это значит, что каждый, включая получателя или ваших врагов), может &quot;воспроизвести&quot; транзакцию снова, снова и снова, пока все ваши эфиры не исчезнут, просто скопировав и вставив вашу оригинальную транзакцию и повторно отправив ее в сеть. Однако благодаря значению nonce, включенному в данные транзакции, каждая транзакция уникальна, даже при многократной отправке одного и того же количества ether на один и тот же адрес получателя. Таким образом, благодаря тому, что увеличивающееся значение nonce является частью транзакции, никто не сможет &quot;продублировать&quot; совершенный вами платеж.</p>
</li>
</ol>
<p>Подводя итог, важно отметить, что использование nonce фактически жизненно необходимо для протокола, основанного на счетах, в отличие от механизма &quot;выхода неизрасходованных транзакций&quot; (UTXO) протокола Bitcoin.</p>
<h3 id="Отслеживание-нецелочисленных-данных"><a class="header" href="#Отслеживание-нецелочисленных-данных">Отслеживание нецелочисленных данных</a></h3>
<p>С практической точки зрения, nonce - это актуальный подсчет количества подтвержденных (т.е. находящихся на цепи) транзакций, которые были произведены со счета. Чтобы узнать значение nonce для адреса, вы можете опросить блокчейн, например, через интерфейс web3. </p>
<p>Откройте консоль JavaScript в Geth (или предпочитаемом вами интерфейсе web3) в тестовой сети Ropsten, затем введите:</p>
<pre><code>&gt; web3.eth.getTransactionCount(&quot;0x9e713963a92c02317a681b9bb3065a8249de124f&quot;)
40
</code></pre>
<p><strong>Совет:</strong> Nonce - это счетчик, первое значение которого 0. В нашем примере количество транзакций равно 40, то есть были просмотрены nonce с 0 по 39. Nonce следующей транзакции должен быть равен 40.</p>
<p>Ваш кошелек будет отслеживать nonce для каждого адреса, которым он управляет. Это довольно просто сделать, если вы проводите транзакции только из одной точки. Допустим, вы пишете собственное программное обеспечение для кошелька или какое-то другое приложение, создающее транзакции. Как вы отслеживаете nonce?</p>
<p>Когда вы создаете новую транзакцию, вы назначаете следующий nonce в последовательности. Но пока она не подтверждена, она не будет учитываться при подсчете <strong>getTransactionCount</strong>.</p>
<p><strong>Предупреждение:</strong> Будьте осторожны при использовании функции <strong>getTransactionCount</strong> для подсчета отложенных транзакций, поскольку вы можете столкнуться с некоторыми проблемами, если отправите несколько транзакций подряд.</p>
<p>Давайте рассмотрим пример:</p>
<pre><code>&gt; web3.eth.getTransactionCount(&quot;0x9e713963a92c02317a681b9bb3065a8249de124f&quot;, &quot;pending&quot;)
40
&gt; web3.eth.sendTransaction({from: web3.eth.accounts[0], to: \
&quot;0xB0920c523d582040f2BCB1bD7FB1c7C1ECEbdB34&quot;, value: web3.utils.toWei(0.01, &quot;ether&quot;)});
&gt; web3.eth.getTransactionCount(&quot;0x9e713963a92c02317a681b9bb3065a8249de124f&quot;, \
&quot;pending&quot;)
41
&gt; web3.eth.sendTransaction({from: web3.eth.accounts[0], to: \
&quot;0xB0920c523d582040f2BCB1bD7FB1c7C1ECEbdB34&quot;, value: web3.utils.toWei(0.01, &quot;ether&quot;)});
&gt; web3.eth.getTransactionCount(&quot;0x9e713963a92c02317a681b9bb3065a8249de124f&quot;, \
&quot;pending&quot;)
41
&gt; web3.eth.sendTransaction({from: web3.eth.accounts[0], to: \
&quot;0xB0920c523d582040f2BCB1bD7FB1c7C1ECEbdB34&quot;, value: web3.utils.toWei(0.01, &quot;ether&quot;)});
&gt; web3.eth.getTransactionCount(&quot;0x9e713963a92c02317a681b9bb3065a8249de124f&quot;, \
&quot;pending&quot;)
41
</code></pre>
<p>Как вы можете видеть, первая отправленная нами транзакция увеличила счетчик транзакций до 41, показывая ожидающую транзакцию. Но когда мы быстро отправили еще три транзакции, вызов <strong>getTransactionCount</strong> не засчитал их. Он посчитал только одну, хотя можно было бы ожидать, что в пуле mempool ожидают три транзакции. Если мы подождем несколько секунд, чтобы сетевые взаимодействия успокоились, вызов <strong>getTransactionCount</strong> вернет ожидаемое число. Но в промежутке, пока ожидает выполнения более одной транзакции, это может нам не помочь.</p>
<p>Когда вы создаете приложение, которое конструирует транзакции, оно не может полагаться на getTransactionCount для отложенных транзакций. Только когда количество ожидающих и подтвержденных транзакций равно (все незавершенные транзакции подтверждены), вы можете доверять результату getTransactionCount для запуска вашего счетчика nonce. После этого отслеживайте nonce в своем приложении до тех пор, пока каждая транзакция не подтвердится.</p>
<h3 id="Пробелы-в-nonce-дублирование-nonce-и-подтверждение"><a class="header" href="#Пробелы-в-nonce-дублирование-nonce-и-подтверждение">Пробелы в nonce, дублирование nonce и подтверждение</a></h3>
<p>Важно отслеживать nonce, если вы создаете транзакции программно, особенно если вы делаете это из нескольких независимых процессов одновременно.</p>
<p>Сеть Ethereum обрабатывает транзакции последовательно, на основе nonce. Это означает, что если вы передадите транзакцию с nonce 0, а затем передадите транзакцию с nonce 2, вторая транзакция не будет включена ни в один блок. Она будет храниться в mempool, в то время как сеть Ethereum будет ждать появления недостающего nonce. Все узлы будут считать, что недостающий nonce просто задержался и что транзакция с nonce 2 была получена не по порядку.</p>
<p>Если вы затем передадите транзакцию с отсутствующим nonce 1, обе транзакции (nonces 1 и 2) будут обработаны и включены (если они действительны, конечно). Как только вы заполните пробел, сеть сможет добыть транзакцию, не соответствующую последовательности, которую она хранила в mempool.</p>
<p>Это означает, что если вы последовательно создадите несколько транзакций и одна из них не будет официально включена ни в один блок, все последующие транзакции &quot;застрянут&quot;, ожидая недостающий nonce. Транзакция может создать непреднамеренный &quot;пробел&quot; в последовательности nonce, потому что она например недействительна или имеет недостаточное количество газа. Чтобы возобновить работу, необходимо передать действительную транзакцию с недостающим nonce. Следует также помнить, что как только транзакция с &quot;недостающим&quot; nonce будет подтверждена сетью, все транзакции с последующими nonce будут постепенно становиться действительными; &quot;отозвать&quot; транзакцию невозможно!</p>
<p>С другой стороны, если вы случайно продублируете nonce, например, передадите две транзакции с одинаковым nonce, но разными получателями или значениями, то одна из них будет подтверждена, а другая отклонена. Какая из них будет подтверждена, определяется последовательностью, в которой они приходят на первый проверяющий узел, который их получает - т.е. это будет достаточно случайным.</p>
<p>Как вы видите, учет nonce необходим, и если ваше приложение не будет правильно управлять этим процессом, вы столкнетесь с проблемами. К сожалению, все становится еще сложнее, если вы пытаетесь делать это одновременно, как мы увидим в следующем разделе.</p>
<h4 id="Параллельность-возникновение-транзакций-и-нераспространенные-данные"><a class="header" href="#Параллельность-возникновение-транзакций-и-нераспространенные-данные">Параллельность, возникновение транзакций и нераспространенные данные</a></h4>
<p>Параллелизм - сложный аспект в компьютерной науке, и иногда он возникает неожиданно, особенно в децентрализованных и распределенных системах реального времени, таких как Ethereum.</p>
<p>Проще говоря, параллелизм - это одновременное выполнение вычислений несколькими независимыми системами. Они могут быть в одной программе (например, многопоточность), на одном процессоре (например, многопроцессорность) или на разных компьютерах (т.е. распределенные системы). Ethereum, по определению, является системой, допускающей параллельность операций (узлы, клиенты, DApps), но обеспечивающей единое состояние посредством консенсуса.</p>
<p>Теперь представьте, что у вас есть несколько независимых приложений кошельков, которые генерируют транзакции с одного и того же адреса или адресов. Одним из примеров такой ситуации может быть биржа, обрабатывающая снятие средств с горячего кошелька биржи (кошелек, ключи которого хранятся онлайн, в отличие от холодного кошелька, где ключи никогда не находятся онлайн). В идеале необходимо иметь несколько компьютеров, обрабатывающих снятие средств, чтобы они не стали узким местом или единой точкой отказа. Однако это быстро становится проблематичным, поскольку наличие более одного компьютера, производящего изъятия, приведет к некоторым сложным проблемам параллелизма, не последней из которых является выбор nonce. Как координируются несколько компьютеров, генерирующих, подписывающих и транслирующих транзакции с одного и того же счета &quot;горячего&quot; кошелька?</p>
<p>Вы можете использовать один компьютер для назначения nonce в порядке очереди компьютерам, подписывающим транзакции. Однако теперь этот компьютер является единой точкой отказа. Хуже того, если назначено несколько nonce и один из них никогда не будет использован (из-за сбоя в компьютере, обрабатывающем транзакцию с этим nonce), все последующие транзакции застревают.</p>
<p>Другой подход заключается в том, чтобы генерировать транзакции, но не присваивать им nonce (и, следовательно, оставлять их неподписанными - помните, что nonce является неотъемлемой частью данных транзакции и поэтому должен быть включен в цифровую подпись, подтверждающую подлинность транзакции). Затем их можно поставить в очередь на один узел, который подписывает их, а также отслеживает nonce. Хотя, опять же, это было бы узким местом в процессе: подписание и отслеживание nonce - это та часть вашей операции, которая, скорее всего, будет перегружена под нагрузкой, в то время как генерация неподписанной транзакции - это та часть, которую вам не нужно распараллеливать. У вас будет некоторый параллелизм, но он будет отсутствовать в критической части процесса.</p>
<p>В конечном итоге, эти проблемы параллелизма, а также сложность отслеживания баланса счетов и подтверждения транзакций в независимых процессах, заставляют большинство реализаций избегать параллелизма и создавать узкие места, такие как единый процесс, обрабатывающий все транзакции вывода средств на бирже, или создание нескольких горячих кошельков, которые могут работать совершенно независимо для вывода средств и нуждаются только в периодической ребалансировке.</p>
<p>СДЕЛАТЬ:</p>
<h2 id="Транзакционный-газ"><a class="header" href="#Транзакционный-газ">Транзакционный газ</a></h2>
<p>Мы немного говорили о газе в предыдущих главах, а более подробно обсуждаем его в [gas]. Однако давайте рассмотрим некоторые основы роли компонентов gasPrice и gasLimit в транзакции.</p>
<p>Газ - это топливо для Ethereum. Газ не является эфиром - это отдельная виртуальная валюта со своим собственным курсом по отношению к эфиру. Ethereum использует газ для контроля количества ресурсов, которые может использовать транзакция, поскольку она будет обрабатываться на тысячах компьютеров по всему миру. Модель бессрочных (по Тьюрингу) вычислений требует определенной формы учета, чтобы избежать атак типа &quot;отказ в обслуживании&quot; или непреднамеренных транзакций, истощающих ресурсы.</p>
<p>Газ отделен от ether, чтобы защитить систему от волатильности, которая может возникнуть при быстрых изменениях стоимости ether, а также как способ управления важными и чувствительными соотношениями между стоимостью различных ресурсов, за которые платит газ (а именно, вычислений, памяти и хранения).</p>
<p>Поле gasPrice в транзакции позволяет инициатору транзакции установить цену, которую он готов заплатить в обмен на газ. Цена измеряется в вэй за единицу газа. Например, в примере транзакции в [intro_chapter] ваш кошелек установил gasPrice равным 3 gwei (3 гигавея или 3 миллиарда вэев).</p>
<p><strong>Совет:</strong> Популярный сайт ETH Gas Station предоставляет информацию о текущих ценах на газ и другие актуальные метрики газа для основной сети Ethereum.</p>
<p>Кошельки могут регулировать цену gasPrice в транзакциях, которые они инициируют, чтобы добиться более быстрого подтверждения транзакций. Чем выше цена gasPrice, тем быстрее транзакция будет подтверждена. И наоборот, транзакции с более низким приоритетом могут иметь более низкую цену, что приведет к более медленному подтверждению. Минимальное значение, на которое можно установить gasPrice, равно нулю, что означает транзакцию без комиссии. В периоды низкого спроса на место в блоке такие транзакции вполне могут быть добыты.</p>
<p><strong>Примечание:</strong> Минимально допустимая цена gasPrice равна нулю. Это означает, что кошельки могут генерировать совершенно бесплатные транзакции. В зависимости от мощности, они могут никогда не быть подтверждены, но в протоколе нет ничего, что запрещало бы бесплатные транзакции. Вы можете найти несколько примеров таких транзакций, успешно включенных в блокчейн Ethereum.</p>
<p>Интерфейс web3 предлагает предложение gasPrice, вычисляя медианную цену по нескольким кварталам (для этого можно использовать консоль truffle или любую консоль JavaScript web3):</p>
<pre><code>&gt; web3.eth.getGasPrice(console.log)
&gt; null BigNumber { s: 1, e: 10, c: [ 10000000000 ] }
</code></pre>
<p>Второе важное поле, связанное с газом, - это gasLimit. Проще говоря, gasLimit - это максимальное количество единиц газа, которое инициатор транзакции готов купить для завершения транзакции. Для простых платежей, то есть транзакций, которые переводят эфир с одного EOA на другой EOA, необходимое количество газа установлено на уровне 21 000 единиц газа. Чтобы рассчитать, сколько ether это будет стоить, умножьте 21 000 на цену газа, которую вы готовы заплатить. Например:</p>
<pre><code>&gt; web3.eth.getGasPrice(function(err, res) {console.log(res*21000)} )
&gt; 210000000000000
</code></pre>
<p>Если конечным адресом вашей сделки является контракт, то количество необходимого газа можно оценить, но нельзя определить с точностью. Это связано с тем, что контракт может оценивать различные условия, которые приводят к различным путям выполнения, с различными общими затратами на газ. Контракт может выполнить только простой расчет или более сложный, в зависимости от условий, которые находятся вне вашего контроля и не могут быть предсказаны. Чтобы продемонстрировать это, давайте рассмотрим пример: мы можем написать умный контракт, который увеличивает счетчик при каждом вызове и выполняет определенный цикл количество раз, равное количеству вызовов. Возможно, на 100-м вызове он выдает специальный приз, как в лотерее, но для вычисления приза необходимо произвести дополнительные вычисления. Если вы вызовете контракт 99 раз, произойдет одно, но на 100-м вызове произойдет нечто совсем другое. Количество газа, которое вы заплатите за это, зависит от того, сколько других транзакций вызвали эту функцию до того, как ваша транзакция будет включена в блок. Возможно, ваша оценка основана на том, чтобы быть 99-й транзакцией, но прямо перед подтверждением вашей транзакции кто-то другой вызывает контракт в 99-й раз. Теперь вы - 100-я вызванная транзакция, и вычислительные усилия (и стоимость газа) намного выше.</p>
<p>Если воспользоваться распространенной аналогией, используемой в Ethereum, можно представить, что gasLimit - это емкость топливного бака вашего автомобиля (ваш автомобиль - это транзакция). Вы заливаете в бак столько бензина, сколько, по вашему мнению, потребуется для поездки (вычислений, необходимых для подтверждения вашей транзакции). Вы можете в какой-то степени оценить это количество, но могут произойти неожиданные изменения в вашем путешествии, например, отклонение (более сложный путь выполнения), которые увеличат расход топлива.</p>
<p>Однако аналогия с топливным баком несколько обманчива. На самом деле это больше похоже на кредитный счет на заправке компании, где вы платите после завершения поездки, исходя из того, сколько бензина вы фактически использовали. Когда вы передаете транзакцию, одним из первых шагов проверки является проверка того, что на счете, с которого она была произведена, достаточно ether для оплаты gasPrice * gasLimit. Но сумма фактически не списывается с вашего счета до завершения транзакции. Счет выставляется только за газ, фактически потребленный вашей транзакцией, но перед отправкой транзакции у вас должен быть достаточный баланс для максимальной суммы, которую вы готовы заплатить.</p>
<h2 id="Получатель-транзакции"><a class="header" href="#Получатель-транзакции">Получатель транзакции</a></h2>
<p>Получатель транзакции указывается в поле to. Оно содержит 20-байтовый адрес Ethereum. Адрес может быть адресом EOA или адресом контракта.
Ethereum не проводит дополнительной проверки этого поля. Любое 20-байтовое значение считается действительным. Если 20-байтовое значение соответствует адресу без соответствующего закрытого ключа или без соответствующего контракта, транзакция все равно считается действительной. Ethereum не имеет возможности узнать, был ли адрес правильно получен из существующего открытого ключа (и, следовательно, из закрытого ключа).</p>
<p><strong>Предупреждение:</strong> Протокол Ethereum не проверяет адреса получателей в транзакциях. Вы можете отправить на адрес, не имеющий соответствующего закрытого ключа или контракта, и тем самым &quot;сжечь&quot; эфир, навсегда лишив его возможности расходования. Валидация должна осуществляться на уровне пользовательского интерфейса.</p>
<p>Отправка транзакции на неправильный адрес, вероятно, сожжет отправленный эфир, сделав его навсегда недоступным (неизрасходованным), поскольку большинство адресов не имеют известного закрытого ключа, и поэтому невозможно сгенерировать подпись для его расходования. Предполагается, что проверка адреса происходит на уровне пользовательского интерфейса (см. [EIP55]). На самом деле, существует ряд веских причин для сжигания ether - например, в качестве сдерживающего фактора для мошенничества в платежных каналах и других смарт-контрактах - и поскольку количество ether ограничено, сжигание ether эффективно распределяет сжигаемую стоимость между всеми держателями ether (пропорционально количеству имеющегося у них ether).</p>
<h2 id="Стоимость-сделки-и-данные"><a class="header" href="#Стоимость-сделки-и-данные">Стоимость сделки и данные</a></h2>
<p>Основная &quot;полезная нагрузка&quot; транзакции содержится в двух полях: значение и данные. Транзакции могут иметь как значение, так и данные, только значение, только данные или ни значение, ни данные. Все четыре комбинации являются допустимыми.</p>
<p>Транзакция, содержащая только стоимость, - это платеж. Транзакция, содержащая только данные, является вызовом. Транзакция, содержащая и стоимость, и данные, является и платежом, и вызовом. Транзакция, не содержащая ни ценности, ни данных - ну, это, вероятно, просто пустая трата газа! Но это все еще возможно.</p>
<p>Давайте попробуем все эти комбинации. Сначала мы зададим адреса источника и назначения из нашего кошелька, просто чтобы демонстрацию было легче читать:</p>
<pre><code>src = web3.eth.accounts[0];
dst = web3.eth.accounts[1];
</code></pre>
<p>Наша первая транзакция содержит только значение (платеж) и не содержит никакой полезной нагрузки в виде данных:</p>
<pre><code>web3.eth.sendTransaction({from: src, to: dst, value: web3.utils.toWei(0.01, &quot;эфир&quot;), data: &quot;&quot;});
</code></pre>
<p>Наш кошелек показывает экран подтверждения с указанием значения для отправки, как показано в кошельке Parity, показывающем транзакцию со значением, но без данных.</p>
<p><img src="./kartinki/parity_txdemo_value_nodata.png" alt="Кошелек Parity, показывающий транзакцию с ценностью, но без данных" />
Рисунок 1. Кошелек Parity, показывающий транзакцию с ценностью, но без данных</p>
<p>В следующем примере указывается как значение, так и полезная нагрузка данных:</p>
<pre><code>web3.eth.sendTransaction({from: src, to: dst, value: web3.utils.toWei(0.01, &quot;ether&quot;), data: &quot;0x1234&quot;});
</code></pre>
<p>Наш кошелек показывает экран подтверждения с указанием значения для отправки, а также полезного груза данных, как показано в кошельке Parity, где показана транзакция со значением и данными.</p>
<p><img src="./kartinki/parity_txdemo_value_data.png" alt="Кошелек Parity, показывающий транзакцию с ценностью и данными" />
Рисунок 2. Кошелек Parity, показывающий транзакцию с ценностью и данными</p>
<p>Следующая транзакция включает полезную нагрузку данных, но указывает значение ноль:
<code>web3.eth.sendTransaction({from: src, to: dst, value: 0, data: &quot;0x1234&quot;});</code></p>
<p>Наш кошелек показывает экран подтверждения с указанием нулевой стоимости и данных, как показано в кошельке Parity, где показана транзакция без стоимости, только данные.</p>
<p><img src="kartinki/parity_txdemo_novalue_data.png" alt="Кошелек Parity, показывающий транзакцию без стоимости, только данные" />
Рисунок 3. Кошелек Parity, показывающий транзакцию без стоимости, только данные</p>
<p>Наконец, последняя транзакция не содержит ни значения для отправки, ни полезной нагрузки в виде данных:</p>
<p><code>web3.eth.sendTransaction({from: src, to: dst, value: 0, data: &quot;&quot;}));</code></p>
<p>Наш кошелек показывает экран подтверждения с нулевой стоимостью, как показано в кошельке Parity, показывающем транзакцию без стоимости и без данных.</p>
<p><img src="./kartinki/parity_txdemo_novalue_nodata.png" alt="Кошелек Parity, показывающий транзакцию без стоимости и без данных" />
Рисунок 4. Кошелек Parity, показывающий транзакцию без стоимости и без данных</p>
<h3 id="Передача-стоимости-в-ЭОА-и-контракты"><a class="header" href="#Передача-стоимости-в-ЭОА-и-контракты">Передача стоимости в ЭОА и контракты</a></h3>
<p>Когда вы создаете транзакцию Ethereum, содержащую значение, это эквивалент платежа. Такие транзакции ведут себя по-разному в зависимости от того, является ли адрес назначения контрактом или нет.</p>
<p>Для адресов EOA, а точнее для любого адреса, который не отмечен на блокчейне как контракт, Ethereum зафиксирует изменение состояния, добавив отправленное вами значение к балансу адреса. Если адрес не был замечен ранее, он будет добавлен во внутреннее представление состояния клиента, а его баланс будет инициализирован значением вашего платежа.</p>
<p>Если адрес назначения (to) является контрактом, то EVM выполнит контракт и попытается вызвать функцию, названную в полезной нагрузке данных вашей транзакции. Если в вашей транзакции нет данных, EVM вызовет резервную функцию и, если эта функция является платной, выполнит ее, чтобы определить, что делать дальше. Если в функции отката нет кода, то эффектом транзакции будет увеличение баланса контракта, в точности как при платеже на кошелек. Если запасной функции нет или она не оплачивается, то транзакция будет отменена.</p>
<p>Контракт может отклонять входящие платежи, выбрасывая исключение непосредственно при вызове функции или в соответствии с условиями, закодированными в функции. Если функция завершается успешно (без исключения), то состояние контракта обновляется, чтобы отразить увеличение баланса ether контракта.</p>
<h3 id="Передача-полезной-нагрузки-данных-в-eoa-или-контракт"><a class="header" href="#Передача-полезной-нагрузки-данных-в-eoa-или-контракт">Передача полезной нагрузки данных в EOA или контракт</a></h3>
<p>Когда ваша транзакция содержит данные, они, скорее всего, адресованы на адрес контракта. Это не означает, что вы не можете отправить полезную нагрузку в виде данных на EOA - это вполне допустимо в протоколе Ethereum. Однако в этом случае интерпретация данных зависит от кошелька, который вы используете для доступа к EOA. Протокол Ethereum их игнорирует. Большинство кошельков также игнорируют любые данные, полученные при транзакции к EOA, которую они контролируют. В будущем, возможно, появятся стандарты, которые позволят кошелькам интерпретировать данные так же, как это делают контракты, что позволит транзакциям вызывать функции, работающие внутри пользовательских кошельков. Критическое различие заключается в том, что любая интерпретация полезной нагрузки данных со стороны EOA не подчиняется правилам консенсуса Ethereum, в отличие от исполнения контракта.</p>
<p>Пока предположим, что ваша транзакция доставляет данные по адресу контракта. В этом случае данные будут интерпретированы EVM как вызов контракта. Большинство контрактов используют эти данные более конкретно, как вызов функции, вызывая именованную функцию и передавая ей любые закодированные аргументы.</p>
<p>Полезная нагрузка данных, отправляемая в ABI-совместимый контракт (можно предположить, что все контракты являются таковыми), представляет собой шестнадцатеричную кодировку:</p>
<h4 id="Селектор-функций"><a class="header" href="#Селектор-функций">Селектор функций</a></h4>
<p>Первые 4 байта хэша Keccak-256 прототипа функции. Это позволяет контракту однозначно определить, какую функцию вы хотите вызвать.</p>
<h4 id="Аргументы-функции"><a class="header" href="#Аргументы-функции">Аргументы функции</a></h4>
<p>Аргументы функции, закодированные в соответствии с правилами для различных элементарных типов, определенных в спецификации ABI.</p>
<p>В [solidity_faucet_example] мы определили функцию для снятия денег:</p>
<p><code>function withdraw(uint withdraw_amount) public {</code></p>
<p>Прототип функции определяется как строка, содержащая имя функции, за которым следуют типы данных каждого из ее аргументов, заключенные в круглые скобки и разделенные запятыми. Имя функции здесь - withdraw, и она принимает один аргумент, который является uint (это псевдоним uint256), поэтому прототипом функции withdraw будет:</p>
<p><code>withdraw(uint256)</code></p>
<p>Давайте вычислим хэш Keccak-256 этой строки:</p>
<pre><code>&gt; web3.utils.sha3(&quot;withdraw(uint256)&quot;);
'0x2e1a7d4d13322e7b96f9a57413e1525c250fb7a9021cf91d1540d5b69f16a49f'
</code></pre>
<p>Первые 4 байта хэша - 0x2e1a7d4d. Это наше значение &quot;function selector&quot;, которое сообщит контракту, какую функцию мы хотим вызвать.</p>
<p>Далее вычислим значение, которое будет передано в качестве аргумента withdraw_amount. Мы хотим снять 0,01 ether. Закодируем это в шестнадцатеричную последовательность big-endian беззнакового 256-битного целого числа, обозначаемого в wei:</p>
<pre><code>&gt; withdraw_amount = web3.utils.toWei(0.01, &quot;эфир&quot;);
'10000000000000000'
&gt; withdraw_amount_hex = web3.utils.toHex(withdraw_amount);
'0x2386f26fc10000'
</code></pre>
<p>Теперь мы добавляем селектор функции к сумме (заполненной до 32 байт):
<code>2e1a7d4d000000000000000000000000000000000000000000000000002386f26fc10000</code></p>
<p>Это полезная нагрузка данных для нашей транзакции, вызывающей функцию withdraw и запрашивающей 0,01 ether в качестве суммы withdraw_amount.</p>
<h2 id="Специальная-транзакция-Создание-контракта"><a class="header" href="#Специальная-транзакция-Создание-контракта">Специальная транзакция: Создание контракта</a></h2>
<p>Особый случай, о котором следует упомянуть, - это транзакция, создающая новый контракт на блокчейне, развертывая его для будущего использования. Транзакции создания контракта отправляются на специальный адрес назначения, называемый нулевым адресом; поле to в транзакции регистрации контракта содержит адрес 0x0. Этот адрес не представляет ни EOA (нет соответствующей пары закрытый-публичный ключ), ни контракт. Он не может тратить эфир или инициировать транзакцию. Он используется только в качестве адресата, со специальным значением &quot;создать этот контракт&quot;.</p>
<p>Хотя нулевой адрес предназначен только для создания контрактов, на него иногда поступают платежи с различных адресов. Этому есть два объяснения: либо это случайность, приводящая к потере ether, либо это намеренное сжигание ether (преднамеренное уничтожение ether путем отправки его на адрес, с которого он никогда не сможет быть потрачен). Однако если вы хотите произвести преднамеренное сжигание ether, вам следует сообщить о своем намерении сети и вместо этого использовать специально выделенный адрес для сжигания:</p>
<p><code>0x000000000000000000000000000000000000dEaD</code></p>
<p><strong>Предупреждение:</strong> Любой эфир, отправленный на указанный адрес для сжигания, станет нерасходуемым и будет потерян навсегда.</p>
<p>Транзакция создания контракта должна содержать только полезную нагрузку данных, содержащую скомпилированный байткод, который создаст контракт. Единственный эффект этой транзакции - создание контракта. Вы можете включить сумму ether в поле значения, если хотите установить новый контракт с начальным балансом, но это совершенно необязательно. Если вы отправляете значение (эфир) на адрес создания контракта без полезной нагрузки данных (без контракта), то эффект будет таким же, как и при отправке на адрес сгорания - нет контракта для зачисления, поэтому эфир теряется.</p>
<p>В качестве примера мы можем создать контракт Faucet.sol, использованный в [intro_chapter], вручную создав транзакцию на нулевой адрес с контрактом в полезной нагрузке данных. Контракт необходимо скомпилировать в представление байткода. Это можно сделать с помощью компилятора Solidity:</p>
<pre><code>$ solc --bin Faucet.sol

Binary:
6060604052341561000f57600080fd5b60e58061001d6000396000f30060606040526004361060...
</code></pre>
<p>Эту же информацию можно получить из онлайн-компилятора Remix.</p>
<p>Теперь мы можем создать транзакцию:</p>
<pre><code>&gt; src = web3.eth.accounts[0];
&gt; faucet_code = \
  &quot;0x6060604052341561000f57600080fd5b60e58061001d6000396000f300606...f0029&quot;;
&gt; web3.eth.sendTransaction({from: src, to: 0, data: faucet_code, \
  gas: 113558, gasPrice: 200000000000});

&quot;0x7bcc327ae5d369f75b98c0d59037eec41d44dfae75447fd753d9f2db9439124b&quot;
</code></pre>
<p>Хорошей практикой является всегда указывать параметр to, даже в случае создания контракта с нулевым адресом, поскольку цена случайной отправки ether на 0x0 и его потери навсегда слишком велика. Также следует указать gasPrice и gasLimit.</p>
<p>Как только контракт будет добыт, мы сможем увидеть его в блокчейн-проводнике Etherscan, как показано в Etherscan, где контракт успешно добыт.</p>
<p><img src="./kartinki/contract_published.png" alt="Эфирскан, показывающий успешно добытый контракт" />
Рисунок 5. Эфирскан, показывающий успешно добытый контракт</p>
<p>Мы можем посмотреть на квитанцию о сделке, чтобы получить информацию о контракте:</p>
<pre><code>&gt; web3.eth.getTransactionReceipt( \
  &quot;0x7bcc327ae5d369f75b98c0d59037eec41d44dfae75447fd753d9f2db9439124b&quot;);

{
  blockHash: &quot;0x6fa7d8bf982490de6246875deb2c21e5f3665b4422089c060138fc3907a95bb2&quot;,
  blockNumber: 3105256,
  contractAddress: &quot;0xb226270965b43373e98ffc6e2c7693c17e2cf40b&quot;,
  cumulativeGasUsed: 113558,
  from: &quot;0x2a966a87db5913c1b22a59b0d8a11cc51c167a89&quot;,
  gasUsed: 113558,
  logs: [],
  logsBloom: \
    &quot;0x00000000000000000000000000000000000000000000000000...00000&quot;,
  status: &quot;0x1&quot;,
  to: null,
  transactionHash: \
    &quot;0x7bcc327ae5d369f75b98c0d59037eec41d44dfae75447fd753d9f2db9439124b&quot;,
  transactionIndex: 0
}
</code></pre>
<p>Сюда входит адрес контракта, который мы можем использовать для отправки средств на контракт и получения средств с него, как показано в предыдущем разделе:</p>
<pre><code>&gt; contract_address = &quot;0xb226270965b43373e98ffc6e2c7693c17e2cf40b&quot;
&gt; web3.eth.sendTransaction({from: src, to: contract_address, \
  value: web3.utils.toWei(0.1, &quot;ether&quot;), data: &quot;&quot;});

&quot;0x6ebf2e1fe95cc9c1fe2e1a0dc45678ccd127d374fdf145c5c8e6cd4ea2e6ca9f&quot;

&gt; web3.eth.sendTransaction({from: src, to: contract_address, value: 0, data: \
  &quot;0x2e1a7d4d000000000000000000000000000000000000000000000000002386f26fc10000&quot;});

&quot;0x59836029e7ce43e92daf84313816ca31420a76a9a571b69e31ec4bf4b37cd16e&quot;
</code></pre>
<p>Через некоторое время обе транзакции видны на Etherscan, как показано в Etherscan, где показаны транзакции по отправке и получению средств.</p>
<p><img src="./kartinki/published_contract_transactions.png" alt="Etherscan, показывающий транзакции по отправке и получению средств" />
Рисунок 6. Etherscan, показывающий транзакции по отправке и получению средств</p>
<h2 id="Цифровые-подписи"><a class="header" href="#Цифровые-подписи">Цифровые подписи</a></h2>
<p>До сих пор мы не вдавались в подробности о цифровых подписях. В этом разделе мы рассмотрим, как работают цифровые подписи и как их можно использовать для представления доказательства владения закрытым ключом без раскрытия этого закрытого ключа.</p>
<h3 id="Алгоритм-эллиптической-кривой-цифровой-подписи"><a class="header" href="#Алгоритм-эллиптической-кривой-цифровой-подписи">Алгоритм эллиптической кривой цифровой подписи</a></h3>
<p>Алгоритм цифровой подписи, используемый в Ethereum, - это алгоритм цифровой подписи на основе эллиптической кривой (ECDSA). Он основан на парах закрытых и открытых ключей с эллиптической кривой, как описано в [elliptic_curve].</p>
<p>Цифровая подпись служит трем целям в Ethereum (см. следующую боковую панель). Во-первых, подпись доказывает, что владелец закрытого ключа, который по косвенным признакам является владельцем счета в Ethereum, санкционировал расходование ether или выполнение контракта. Во-вторых, она гарантирует неотказуемость: доказательство авторизации является неоспоримым. В-третьих, подпись доказывает, что данные транзакции не были и не могут быть изменены кем-либо после подписания транзакции.</p>
<p>Определение цифровой подписи в Википедии
Цифровая подпись - это математическая схема для подтверждения подлинности цифровых сообщений или документов. Действительная цифровая подпись дает получателю основания полагать, что сообщение было создано известным отправителем (аутентификация), что отправитель не может отрицать факт отправки сообщения (неотрицание) и что сообщение не было изменено при передаче (целостность).
Источник: https://en.wikipedia.org/wiki/Digital_signature</p>
<h3 id="Как-работают-цифровые-подписи"><a class="header" href="#Как-работают-цифровые-подписи">Как работают цифровые подписи</a></h3>
<p>Цифровая подпись - это математическая схема, состоящая из двух частей. Первая часть - это алгоритм создания подписи с помощью закрытого ключа (ключа подписи) из сообщения (в нашем случае это транзакция). Вторая часть - это алгоритм, который позволяет любому человеку проверить подпись, используя только сообщение и открытый ключ.</p>
<h4 id="Создание-цифровой-подписи"><a class="header" href="#Создание-цифровой-подписи">Создание цифровой подписи</a></h4>
<p>В реализации ECDSA в Ethereum &quot;сообщение&quot;, которое подписывается, - это транзакция, а точнее, хэш Keccak-256 данных транзакции, закодированных в RLP. Ключом подписи является закрытый ключ EOA. Результатом является подпись:
S i g = F sig ( F keccak256 ( m ) , k )
где:
k - закрытый ключ подписи.
m - транзакция, закодированная в RLP.
Fkeccak256 - это хэш-функция Keccak-256.
Fsig - алгоритм подписи.
Sig - результирующая подпись.
Функция Fsig создает сигнатуру Sig, состоящую из двух значений, обычно называемых r и s:
S i g = ( r , s )</p>
<h4 id="Проверка-подписи"><a class="header" href="#Проверка-подписи">Проверка подписи</a></h4>
<p>Чтобы проверить подпись, необходимо иметь подпись (r и s), сериализованную транзакцию и открытый ключ, соответствующий закрытому ключу, использованному для создания подписи. По сути, проверка подписи означает, что &quot;только владелец закрытого ключа, создавшего этот открытый ключ, мог создать эту подпись на данной транзакции&quot;.
Алгоритм проверки подписи принимает сообщение (т.е. хэш транзакции для нашего использования), открытый ключ подписанта и подпись (значения r и s) и возвращает true, если подпись действительна для данного сообщения и открытого ключа.</p>
<h4 id="Математика-ecdsa"><a class="header" href="#Математика-ecdsa">Математика ECDSA</a></h4>
<p>Как упоминалось ранее, подписи создаются с помощью математической функции Fsig, которая производит подпись, состоящую из двух значений, r и s. В этом разделе мы рассмотрим функцию Fsig более подробно.</p>
<p>Алгоритм подписи сначала генерирует эфемерный (временный) закрытый ключ криптографически безопасным способом. Этот временный ключ используется при вычислении значений r и s, чтобы гарантировать, что реальный личный ключ отправителя не может быть вычислен злоумышленниками, наблюдающими за подписанными транзакциями в сети Ethereum.</p>
<p>Как мы знаем из [pubkey], эфемерный закрытый ключ используется для получения соответствующего (эфемерного) открытого ключа, поэтому мы имеем:</p>
<ul>
<li>криптографически безопасное случайное число q, которое используется в качестве эфемерного закрытого ключа</li>
<li>Соответствующий эфемерный открытый ключ Q, сгенерированный из q и точки генератора эллиптической кривой G</li>
</ul>
<p>В этом случае значение r цифровой подписи является координатой x эфемерного открытого ключа Q.</p>
<p>Далее алгоритм вычисляет значение s подписи, такое, что:
s ≡ q-1 (Keccak256(m) + r * k) (mod p)
где:
q - эфемерный закрытый ключ.
r - координата x эфемерного открытого ключа.
k - закрытый ключ подписывающего (владельца EOA).
m - данные транзакции.
p - простой порядок эллиптической кривой.</p>
<p>Проверка - это обратная функция генерации подписи, использующая значения r и s и открытый ключ отправителя для вычисления значения Q, которое является точкой на эллиптической кривой (эфемерный открытый ключ, использованный при создании подписи). Этапы работы следующие:
Проверьте правильность формирования всех входов
Вычислите w = s-1 mod p
Рассчитайте u1 = Keccak256(m) * w mod p
Рассчитайте u2 = r * w mod p
Наконец, вычислите точку на эллиптической кривой Q ≡ u1 * G + u2 * K (mod p).
где:
r и s - значения подписи.
K - открытый ключ подписанта (владельца EOA).
m - данные транзакции, которая была подписана.
G - точка генератора эллиптической кривой.
p - простой порядок эллиптической кривой.</p>
<p>Если координата x вычисленной точки Q равна r, то проверяющий может сделать вывод, что подпись действительна.</p>
<p>Обратите внимание, что при проверке подписи закрытый ключ не известен и не раскрыт.</p>
<p><strong>Совет:</strong> ECDSA - это довольно сложная математика; полное объяснение выходит за рамки этой книги. В Интернете можно найти множество замечательных руководств, в которых все объясняется шаг за шагом: наберите в поисковике &quot;ECDSA explained&quot; или попробуйте вот это: http://bit.ly/2r0HhGB.</p>
<h4 id="Подписание-транзакций-на-практике"><a class="header" href="#Подписание-транзакций-на-практике">Подписание транзакций на практике</a></h4>
<p>Чтобы транзакция была действительной, отправитель должен подписать сообщение цифровой подписью, используя алгоритм цифровой подписи с эллиптической кривой. Когда мы говорим &quot;подписать транзакцию&quot;, мы на самом деле имеем в виду &quot;подписать хэш Keccak-256 данных RLP-сериализованной транзакции&quot;. Подпись применяется к хэшу данных транзакции, а не к самой транзакции.</p>
<p>Чтобы подписать транзакцию в Ethereum, инициатор должен:</p>
<ol>
<li>Создайте структуру данных транзакции, содержащую девять полей: nonce, gasPrice, gasLimit, to, value, data, chainID, 0, 0.</li>
<li>Создать RLP-кодированное сериализованное сообщение структуры данных транзакции.</li>
<li>Вычислите хэш Keccak-256 этого сериализованного сообщения.</li>
<li>Вычислите подпись ECDSA, подписав хэш закрытым ключом отправителя EOA.</li>
<li>Добавьте вычисленные значения v, r и s подписи ECDSA к транзакции.</li>
</ol>
<p>Специальная переменная подписи v указывает на две вещи: идентификатор цепочки и идентификатор восстановления, чтобы помочь функции ECDSArecover проверить подпись. Она вычисляется как одно из 27 или 28, либо как удвоенный идентификатор цепочки плюс 35 или 36. Дополнительную информацию об идентификаторе цепочки см. в разделе Создание необработанной транзакции с помощью EIP-155. Идентификатор восстановления (27 или 28 в подписях &quot;старого стиля&quot; или 35 или 36 в полных транзакциях в стиле Spurious Dragon) используется для указания четности y-компонента открытого ключа (подробнее см. раздел Значение префикса подписи (v) и восстановление открытого ключа).</p>
<p><strong>Примечание:</strong> В блоке № 2 675 000 Ethereum реализовал хард форк &quot;Spurious Dragon&quot;, который, среди прочих изменений, ввел новую схему подписания, включающую защиту от воспроизведения транзакций (предотвращение воспроизведения транзакций, предназначенных для одной сети, в других). Эта новая схема подписания указана в EIP-155. Это изменение влияет на форму транзакции и ее подпись, поэтому необходимо обратить внимание на первую из трех переменных подписи (т.е. v), которая принимает одну из двух форм и указывает на поля данных, включенные в хэшируемое сообщение транзакции.</p>
<h4 id="Создание-и-подписание-необработанных-транзакций"><a class="header" href="#Создание-и-подписание-необработанных-транзакций">Создание и подписание необработанных транзакций</a></h4>
<p>В этом разделе мы создадим необработанную транзакцию и подпишем ее, используя библиотеку ethereumjs-tx, которую можно установить с помощью npm. Это демонстрирует функции, которые обычно используются в кошельке или приложении, подписывающем транзакции от имени пользователя. Исходный код этого примера находится в файле raw_tx_demo.js в репозитории GitHub книги:
<code>link:code/web3js/raw_tx/raw_tx_demo.js[]</code></p>
<p>Выполнение кода примера дает следующие результаты:</p>
<pre><code>$ node raw_tx_demo.js
RLP-Encoded Tx: 0xe6808609184e72a0008303000094b0920c523d582040f2bcb1bd7fb1c7c1...
Tx Hash: 0xaa7f03f9f4e52fcf69f836a6d2bbc7706580adce0a068ff6525ba337218e6992
Signed Raw Transaction: 0xf866808609184e72a0008303000094b0920c523d582040f2bcb1...
</code></pre>
<h4 id="Создание-необработанных-транзакций-с-помощью-eip-155"><a class="header" href="#Создание-необработанных-транзакций-с-помощью-eip-155">Создание необработанных транзакций с помощью EIP-155</a></h4>
<p>Стандарт EIP-155 &quot;Простая защита от атак повторного воспроизведения&quot; определяет кодирование транзакций с защитой от атак повторного воспроизведения, которое включает идентификатор цепочки внутри данных транзакции перед подписанием. Это гарантирует, что транзакции, созданные для одного блокчейна (например, основной сети Ethereum), будут недействительны на другом блокчейне (например, Ethereum Classic или тестовой сети Ropsten). Таким образом, транзакции, транслируемые в одной сети, не могут быть воспроизведены в другой, отсюда и название стандарта.</p>
<p>EIP-155 добавляет три поля к основным шести полям структуры данных транзакции, а именно: идентификатор цепочки, 0 и 0. Эти три поля добавляются к данным транзакции до их кодирования и хэширования. Таким образом, они изменяют хэш транзакции, к которому впоследствии применяется подпись. Включая идентификатор цепочки в подписываемые данные, подпись транзакции предотвращает любые изменения, поскольку при изменении идентификатора цепочки подпись становится недействительной. Таким образом, EIP-155 делает невозможным воспроизведение транзакции на другой цепи, поскольку действительность подписи зависит от идентификатора цепи.</p>
<p>Поле идентификатора цепи принимает значение в соответствии с сетью, для которой предназначена транзакция, как описано в разделе Идентификаторы цепи.</p>
<p>Таблица 1. Идентификаторы цепей</p>
<div class="table-wrapper"><table><thead><tr><th>Цепь</th><th>Идентификатор цепи</th></tr></thead><tbody>
<tr><td>Ethereum mainnet</td><td>1</td></tr>
<tr><td>Morden (устаревшее), Expanse</td><td>2</td></tr>
<tr><td>Ropsten</td><td>3</td></tr>
<tr><td>Rinkeby</td><td>4</td></tr>
<tr><td>Основная сеть Rootstock</td><td>30</td></tr>
<tr><td>Испытательная сеть Rootstock</td><td>31</td></tr>
<tr><td>Kovan</td><td>42</td></tr>
<tr><td>Ethereum Classic mainnet</td><td>61</td></tr>
<tr><td>Ethereum Classic testnet</td><td>62</td></tr>
<tr><td>Гетские частные сети</td><td>1337</td></tr>
</tbody></table>
</div>
<p>Полученная структура транзакции кодируется RLP, хэшируется и подписывается. Алгоритм подписи немного модифицирован, чтобы кодировать идентификатор цепочки в префиксе v.</p>
<p>Более подробную информацию см. в спецификации EIP-155.</p>
<h2 id="Значение-префикса-подписи-v-и-восстановление-открытого-ключа"><a class="header" href="#Значение-префикса-подписи-v-и-восстановление-открытого-ключа">Значение префикса подписи (v) и восстановление открытого ключа</a></h2>
<p>Как упоминалось в разделе &quot;Структура транзакции&quot;, сообщение транзакции не включает поле &quot;от&quot;. Это связано с тем, что открытый ключ отправителя может быть вычислен непосредственно из подписи ECDSA. Как только у вас есть открытый ключ, вы можете легко вычислить адрес. Процесс восстановления открытого ключа подписанта называется восстановлением открытого ключа.</p>
<p>Учитывая значения r и s, которые были вычислены в математике ECDSA, мы можем вычислить два возможных открытых ключа.</p>
<p>Сначала мы вычисляем две точки эллиптической кривой, R и R', из значения x координаты r, которое содержится в подписи. Точек две, потому что эллиптическая кривая симметрична относительно оси x, так что для любого значения x есть два возможных значения, которые соответствуют кривой, по одному с каждой стороны оси x.</p>
<p>Из r мы также вычисляем r-1, который является мультипликативной обратной величиной r.</p>
<p>Наконец, мы вычисляем z, который является n младшими битами хэша сообщения, где n - порядок эллиптической кривой.</p>
<p>Два возможных открытых ключа:
K1 = r-1 (sR - zG)
и:
K2 = r-1 (sR' - zG)
где:
K1 и K2 - это два варианта открытого ключа подписанта.
r-1 - это мультипликативная обратная величина значения r подписи.
s - значение подписи.
R и R' - это два варианта эфемерного открытого ключа Q.
z - это n младших битов хэша сообщения.
G - точка генератора эллиптической кривой.</p>
<p>Чтобы сделать работу более эффективной, подпись транзакции включает префиксное значение v, которое сообщает нам, какое из двух возможных значений R является эфемерным открытым ключом. Если v четное, то R - правильное значение. Если v нечетное, то это R'. Таким образом, нам нужно вычислить только одно значение для R и только одно значение для K.</p>
<h2 id="Разделение-подписания-и-передачи-автономное-подписание"><a class="header" href="#Разделение-подписания-и-передачи-автономное-подписание">Разделение подписания и передачи (автономное подписание)</a></h2>
<p>Как только транзакция подписана, она готова к передаче в сеть Ethereum. Три этапа создания, подписания и передачи транзакции обычно выполняются как одна операция, например, с помощью web3.eth.sendTransaction. Однако, как вы видели в разделе &quot;Создание и подписание сырой транзакции&quot;, вы можете создать и подписать транзакцию за два отдельных шага. После того как у вас есть подписанная транзакция, вы можете передать ее с помощью web3.eth.sendSignedTransaction, которая принимает транзакцию в шестнадцатеричном коде и с подписью и передает ее в сеть Ethereum.</p>
<p>Почему вы хотите разделить подписание и передачу транзакций? Наиболее распространенной причиной является безопасность. Компьютер, подписывающий транзакцию, должен иметь разблокированные закрытые ключи, загруженные в память. Компьютер, осуществляющий передачу, должен быть подключен к Интернету (и на нем должен быть запущен клиент Ethereum). Если эти две функции находятся на одном компьютере, то у вас есть закрытые ключи в онлайн-системе, что довольно опасно. Разделение функций подписания и передачи и выполнение их на разных машинах (на офлайн- и онлайн-устройстве соответственно) называется офлайн-подписанием и является обычной практикой безопасности.</p>
<p>Подписание транзакций Ethereum в автономном режиме демонстрирует процесс:</p>
<ol>
<li>Создайте неподписанную транзакцию на сетевом компьютере, где можно получить текущее состояние счета, в частности, текущий nonce и доступные средства</li>
<li>Передача неподписанной транзакции на автономное устройство с &quot;воздушным захватом&quot; для подписания транзакции, например, с помощью QR-кода или USB-накопителя.</li>
<li>Передача подписанной транзакции (обратно) на онлайн-устройство для трансляции в блокчейн Ethereum, например, через QR-код или USB-флеш-накопитель.</li>
</ol>
<p><img src="./kartinki/offline_signing.png" alt="Автономное подписание транзакций Ethereum" />
Рисунок 7. Автономное подписание транзакций Ethereum</p>
<p>В зависимости от уровня безопасности, который вам необходим, ваш компьютер с &quot;автономной подписью&quot; может иметь различную степень отделения от онлайн компьютера, начиная от изолированной подсети с брандмауэром (онлайн, но отделенный) до полностью автономной системы, известной как система с воздушной завесой. В системе air-gapped вообще отсутствует сетевое подключение - компьютер отделен от онлайновой среды &quot;воздушной прослойкой&quot;. Для подписания транзакций вы передаете их на компьютер с воздушной системой и обратно с помощью носителя данных или (лучше) веб-камеры и QR-кода. Конечно, это означает, что вы должны вручную передавать каждую транзакцию, которую вы хотите подписать, и это не подходит для масштабирования.</p>
<p>Хотя не многие среды могут использовать полностью изолированную систему, даже небольшая степень изоляции имеет значительные преимущества для безопасности. Например, изолированная подсеть с брандмауэром, пропускающим только протокол очереди сообщений, может обеспечить гораздо меньшую площадь атаки и гораздо более высокую безопасность, чем при подписи в онлайн-системе. Многие компании используют для этой цели такой протокол, как ZeroMQ (0MQ). При такой настройке транзакции сериализуются и ставятся в очередь на подписание. Протокол постановки в очередь передает сериализованное сообщение, подобно сокету TCP, на подписывающий компьютер. Компьютер для подписания считывает сериализованные транзакции из очереди (тщательно), применяет подпись с соответствующим ключом и помещает их в исходящую очередь. Исходящая очередь передает подписанные транзакции на компьютер с клиентом Ethereum, который снимает их с очереди и передает.</p>
<h2 id="Распространение-транзакций"><a class="header" href="#Распространение-транзакций">Распространение транзакций</a></h2>
<p>В сети Ethereum используется протокол маршрутизации &quot;flood routing&quot;. Каждый клиент Ethereum действует как узел в одноранговой (P2P) сети, которая (в идеале) образует ячеистую сеть. Ни один узел сети не является особенным: все они действуют как равные коллеги. Мы будем использовать термин &quot;узел&quot; для обозначения клиента Ethereum, который подключен к сети P2P и участвует в ней.</p>
<p>Распространение транзакций начинается с создания (или получения из офлайна) подписанного транзакта узлом Ethereum. Транзакция подтверждается, а затем передается всем другим узлам Ethereum, которые непосредственно связаны с узлом-первоисточником. В среднем каждый узел Ethereum поддерживает связь как минимум с 13 другими узлами, называемыми его соседями. Каждый соседний узел проверяет транзакцию, как только получает ее. Если они согласны с тем, что она действительна, они сохраняют ее копию и распространяют ее среди всех своих соседей (кроме того, от которого она поступила). В результате транзакция распространяется от узла-первоисточника по всей сети, пока все узлы в сети не получат копию транзакции. Узлы могут фильтровать сообщения, которые они распространяют, но по умолчанию они распространяют все действительные сообщения о транзакциях, которые они получают.</p>
<p>Всего за несколько секунд транзакция Ethereum распространяется по всем узлам Ethereum по всему миру. С точки зрения каждого узла невозможно определить происхождение транзакции. Сосед, отправивший ее узлу, может быть инициатором транзакции или получить ее от одного из своих соседей. Чтобы иметь возможность отследить происхождение транзакций или помешать их распространению, злоумышленник должен контролировать значительный процент всех узлов. Это является частью конструкции безопасности и конфиденциальности сетей P2P, особенно в применении к сетям blockchain.</p>
<h2 id="Запись-на-блокчейне"><a class="header" href="#Запись-на-блокчейне">Запись на блокчейне</a></h2>
<p>Хотя все узлы в Ethereum являются равноправными, некоторые из них управляются майнерами и передают транзакции и блоки на майнинговые фермы, представляющие собой компьютеры с высокопроизводительными графическими процессорами (GPU). Компьютеры для майнинга добавляют транзакции в блок-кандидат и пытаются найти доказательство работы, которое делает блок-кандидат действительным. Мы обсудим это более подробно в [consensus].</p>
<p>Не вдаваясь в излишние подробности, можно сказать, что действительные транзакции в конечном итоге будут включены в блок транзакций и, таким образом, записаны в блокчейн Ethereum. После майнинга в блок транзакции также изменяют состояние синглтона Ethereum, либо изменяя баланс счета (в случае простого платежа), либо вызывая контракты, которые изменяют их внутреннее состояние. Эти изменения регистрируются вместе с транзакцией в виде квитанции о транзакции, которая также может включать события. Более подробно мы рассмотрим все это в [evm_chapter].</p>
<p>Транзакция, прошедшая путь от создания до подписания EOA, распространения и, наконец, майнинга, изменила состояние синглтона и оставила неизгладимый след в блокчейне.</p>
<h2 id="Транзакции-с-несколькими-подписями-multisig"><a class="header" href="#Транзакции-с-несколькими-подписями-multisig">Транзакции с несколькими подписями (Multisig)</a></h2>
<p>Если вы знакомы со скриптовыми возможностями Bitcoin, то знаете, что можно создать мультисигмальный счет Bitcoin, который может расходовать средства только в том случае, если транзакцию подписывают несколько сторон (например, 2 из 2 или 3 из 4 подписей). Базовые транзакции стоимости EOA в Ethereum не предусматривают множественных подписей; однако произвольные ограничения на подписание могут быть навязаны смарт-контрактами с любыми условиями, которые вы можете придумать, для обработки передачи как ether, так и токенов.</p>
<p>Чтобы воспользоваться этой возможностью, эфир должен быть переведен на &quot;контракт кошелька&quot;, который запрограммирован на желаемые правила расходования средств, такие как требования к многозначности подписи или лимиты расходов (или их комбинации). Затем контракт кошелька отправляет средства по запросу авторизованного EOA после выполнения условий расходования. Например, чтобы защитить эфир в условиях мультисигмы, переведите эфир на контракт с мультисигмой. Когда вы захотите отправить средства на другой счет, все необходимые пользователи должны будут отправить транзакции на контракт с помощью обычного приложения кошелька, фактически уполномочив контракт выполнить окончательную транзакцию.</p>
<p>Эти контракты также могут быть разработаны таким образом, чтобы требовать множественных подписей перед выполнением локального кода или для запуска других контрактов. Безопасность схемы в конечном итоге определяется кодом контракта с несколькими подписями.</p>
<p>Возможность реализовать транзакции с несколькими подписями в виде смарт-контракта демонстрирует гибкость Ethereum. Однако это обоюдоострый меч, поскольку дополнительная гибкость может привести к ошибкам, которые подрывают безопасность схем с несколькими подписями. На самом деле существует ряд предложений по созданию команды мультиподписи в EVM, которая устранит необходимость в смарт-контрактах, по крайней мере, для простых схем мультиподписи M-of-N. Это было бы эквивалентно системе мультиподписи в Биткойне, которая является частью основных правил консенсуса и доказала свою надежность и безопасность.</p>
<h2 id="Выводы"><a class="header" href="#Выводы">Выводы</a></h2>
<p>Транзакции являются отправной точкой любой деятельности в системе Ethereum. Транзакции - это &quot;входные данные&quot;, которые заставляют виртуальную машину Ethereum оценивать контракты, обновлять балансы и в целом изменять состояние блокчейна Ethereum. Далее мы будем работать с умными контрактами более подробно и научимся программировать на контрактно-ориентированном языке Solidity.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../kniga/кошельки.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../kniga/смарт_контракты_на_solidity.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../kniga/кошельки.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../kniga/смарт_контракты_на_solidity.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
