<!DOCTYPE HTML>
<html lang="ru" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Доп 4. Инструменты разработчика - Осваиваем Ethereum - Mastering Ethereum</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Руководство по Ethereum и разработке смарт-контрактов">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../1_предисловие.html">Предисловие</a></li><li class="chapter-item expanded affix "><a href="../2_глоссарий.html">Глоссарий</a></li><li class="chapter-item expanded affix "><li class="part-title">Книга</li><li class="chapter-item expanded "><a href="../kniga/что_такое_ethereum.html"><strong aria-hidden="true">1.</strong> Что такое Ethereum?</a></li><li class="chapter-item expanded "><a href="../kniga/введение.html"><strong aria-hidden="true">2.</strong> Введение</a></li><li class="chapter-item expanded "><a href="../kniga/клиенты.html"><strong aria-hidden="true">3.</strong> Клиенты</a></li><li class="chapter-item expanded "><a href="../kniga/ключи_и_адреса.html"><strong aria-hidden="true">4.</strong> Ключи и адреса</a></li><li class="chapter-item expanded "><a href="../kniga/кошельки.html"><strong aria-hidden="true">5.</strong> Кошельки</a></li><li class="chapter-item expanded "><a href="../kniga/транзакции.html"><strong aria-hidden="true">6.</strong> Транзакции</a></li><li class="chapter-item expanded "><a href="../kniga/смарт_контракты_на_solidity.html"><strong aria-hidden="true">7.</strong> Смарт-контракты на Solidity</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.</strong> Смарт-контракты на Vyper</div></li><li class="chapter-item expanded "><a href="../kniga/безопаность_смарт_контрактов.html"><strong aria-hidden="true">9.</strong> Безопаность смарт-контрактов</a></li><li class="chapter-item expanded "><a href="../kniga/токены.html"><strong aria-hidden="true">10.</strong> Токены</a></li><li class="chapter-item expanded "><a href="../kniga/оракулы.html"><strong aria-hidden="true">11.</strong> Оракулы</a></li><li class="chapter-item expanded "><a href="../kniga/децентрализованные_приложения.html"><strong aria-hidden="true">12.</strong> Децентрализованные приложения</a></li><li class="chapter-item expanded "><a href="../kniga/виртуальная_машина_ethereum.html"><strong aria-hidden="true">13.</strong> Виртуальная машина Ethereum</a></li><li class="chapter-item expanded "><a href="../kniga/консенсус.html"><strong aria-hidden="true">14.</strong> Консенсус</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">15.</strong> Доп 1. История ветвлений</div></li><li class="chapter-item expanded "><a href="../kniga/дополнение_2_стандарты_eip_erc.html"><strong aria-hidden="true">16.</strong> Доп 2. Стандарты EIP, ERC</a></li><li class="chapter-item expanded "><a href="../kniga/дополнение_3_коды_evm_и_gas.html"><strong aria-hidden="true">17.</strong> Доп 3. Коды EVM и газ</a></li><li class="chapter-item expanded "><a href="../kniga/дополнение_4_инструменты_solidity_разработчика.html" class="active"><strong aria-hidden="true">18.</strong> Доп 4. Инструменты разработчика</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">19.</strong> Доп 5. Руководство по web3js</div></li><li class="spacer"></li><li class="chapter-item expanded affix "><a href="../support.html">Поддержка проекта</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Осваиваем Ethereum - Mastering Ethereum</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="Доп-4-Инструменты-разработчика"><a class="header" href="#Доп-4-Инструменты-разработчика">Доп 4. Инструменты разработчика</a></h1>
<h2 id="Инструменты-разработки"><a class="header" href="#Инструменты-разработки">Инструменты разработки</a></h2>
<h3 id="Алхимия"><a class="header" href="#Алхимия">Алхимия</a></h3>
<p>Веб-сайт: https://alchemyapi.io
Документация: https://docs.alchemyapi.io/
Для осуществления транзакций в сети Ethereum разработчикам необходимо либо запустить собственные узлы Geth / Parity для обслуживания запросов, либо использовать инфраструктурную платформу, которая управляет узлами для них и получает запросы JSON-RPC через пользовательскую конечную точку API.</p>
<p>Развертывание самостоятельного узла может быть сопряжено с рядом проблем: это может быть трудоемким и дорогостоящим процессом, требующим значительного инженерного времени для управления, порядка ~7 тыс. долларов США в год на сервер AWS для каждого узла. Кроме того, эти узлы могут быть ненадежными, что чревато такими проблемами, как скачки процессора, сбои в работе пиринга и проблемы с согласованностью, когда узлы не синхронизируются с сетью. Кроме того, определение согласованного состояния сети может стать сложной задачей при масштабировании на несколько узлов, которые в любой момент времени могут видеть несколько разные версии блокчейна.</p>
<p>Провайдер инфраструктуры блокчейна инкапсулирует все сложности управления узлами Ethereum с помощью интерфейса запросов JSON-RPC, который расширяет web3.js. Направляя запросы узлов в конечную точку пользовательского API, разработчики получают доступ ко всему необходимому для взаимодействия с блокчейном Ethereum, гарантируя при этом, что их запросы обслуживаются надежно, с полной корректностью данных и могут быть масштабированы до любого необходимого размера.</p>
<p>Alchemy является одним из таких поставщиков инфраструктуры. Помимо этих гарантий, он также предоставляет дополнительные инструменты для разработчиков, такие как:</p>
<h4 id="api-explorer"><a class="header" href="#api-explorer">API Explorer</a></h4>
<p>Браузерный инструмент, позволяющий разработчикам осуществлять поиск и анализ всех исторических запросов API, отправленных через Alchemy, для отслеживания закономерностей, поиска ошибок и упрощения отладки.</p>
<h4 id="mempool-visualizer"><a class="header" href="#mempool-visualizer">Mempool Visualizer</a></h4>
<p>Браузерный инструмент, позволяющий разработчикам просматривать и искать добытые, ожидающие и отложенные транзакции в мемпуле Alchemy, чтобы они могли отслеживать статус своих транзакций.</p>
<h4 id="composer"><a class="header" href="#composer">Composer</a></h4>
<p>Браузерный инструмент, позволяющий разработчикам выполнять вызовы JSON-RPC непосредственно из приборной панели для создания прототипов и исправления неудачных запросов или изучения поведения новых методов.</p>
<h4 id="Расширенные-api"><a class="header" href="#Расширенные-api">Расширенные API</a></h4>
<p>Набор дополнительных API, предоставляющих инструменты более высокого уровня для помощи разработчикам, такие как возврат баланса токенов, получение метаданных токенов или получение исторических транзакций для любого адреса без необходимости сканирования всего блокчейна.</p>
<h4 id="notify"><a class="header" href="#notify">Notify</a></h4>
<p>Инструмент, использующий веб-крючки, позволяющий разработчикам получать уведомления всякий раз, когда они видят активность на определенном адресе Ethereum, когда транзакции в их mempool добываются или сбрасываются, или когда цены на газ Ethereum падают ниже определенной суммы.</p>
<h4 id="Настройка"><a class="header" href="#Настройка">Настройка</a></h4>
<p>Чтобы использовать продукты Alchemy, вам необходим ключ API для аутентификации ваших запросов. Создайте учетную запись Alchemy, создайте свое первое приложение и выберите &quot;Просмотр ключа&quot; на приборной панели выбранного приложения, чтобы получить новый ключ.</p>
<h4 id="Выполнение-запросов"><a class="header" href="#Выполнение-запросов">Выполнение запросов</a></h4>
<p>Для ручных запросов мы рекомендуем взаимодействовать с JSON-RPC через POST-запросы. Просто передайте заголовок Content-Type: application/json и ваш запрос в качестве тела POST со следующими полями.
jsonrpc: Версия JSON-RPC - в настоящее время поддерживается только 2.0.
метод: Метод API ETH. См. справку по API.
params: Список параметров для передачи в метод.
id: Идентификатор вашего запроса. Будет возвращен ответом, чтобы вы могли отслеживать, к какому запросу относится ответ.
Вот пример, который вы можете запустить из командной строки для получения текущей цены на газ, заменив demo на свой собственный ключ API.</p>
<pre><code>curl https://eth-mainnet.alchemyapi.io/v2/demo \
-X POST \
-H &quot;Content-Type: application/json&quot; \
-d '{&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;method&quot;:&quot;eth_gasPrice&quot;,&quot;params&quot;:[],&quot;id&quot;:73}
</code></pre>
<p>Результаты:</p>
<pre><code>{ &quot;id&quot;: 73,
  &quot;jsonrpc&quot;: &quot;2.0&quot;,
  &quot;result&quot;: &quot;0x09184e72a000&quot; // 10000000000000 
}
</code></pre>
<p>Настройка Alchemy в качестве клиента
Мы рекомендуем использовать AlchemyWeb3.js, расширенную версию web3.js, которая также включает Alchemy Enhanced APIs. Для получения дополнительной информации обратитесь к руководству по Alchemy Web3.
Чтобы установить AlchemyWeb3.js, выполните в командной строке:
С пряжей: добавить пряжу @alch/alchemy-web3
С помощью NPM: npm install @alch/alchemy-web3
Чтобы использовать инфраструктуру узлов Alchemy, запустите в NodeJS или добавьте это в файл JavaScript:</p>
<pre><code>const { createAlchemyWeb3 } = require(&quot;@alch/alchemy-web3&quot;);
const web3 = createAlchemyWeb3(&quot;https://eth-mainnet.alchemyapi.io/v2/your-api-key&quot;);
</code></pre>
<p>В качестве альтернативы вы можете использовать стандартный web3.js, запустив npm install web3 и выполнив приведенный ниже фрагмент кода для использования инфраструктуры Alchemy без расширенных API:</p>
<pre><code>// JavaScript: web3.js
const Web3 = require('web3');
const web3 = new Web3(&quot;https://eth-mainnet.alchemyapi.io/v2/your-api-key&quot;);
</code></pre>
<h2 id="frameworks"><a class="header" href="#frameworks">Frameworks</a></h2>
<p>Для облегчения разработки смарт-контрактов Ethereum можно использовать фреймворки. Делая все самостоятельно, вы лучше понимаете, как все сочетается друг с другом, но это очень утомительная, повторяющаяся работа. Фреймворки, описанные в этом разделе, могут автоматизировать некоторые задачи и облегчить разработку.</p>
<h3 id="Трюфель"><a class="header" href="#Трюфель">Трюфель</a></h3>
<p>GitHub: https://github.com/trufflesuite/truffle
Веб-сайт: https://trufflesuite.com
Документация: https://trufflesuite.com/docs
Коробки с трюфелями: http://trufflesuite.com/boxes/
Репозиторий пакетов npm: https://www.npmjs.com/package/truffle
Установка фреймворка Truffle
Фреймворк Truffle включает в себя несколько пакетов Node.js. Перед установкой Truffle вам необходимо иметь актуальную и рабочую установку Node.js и менеджера пакетов Node (npm).
Рекомендуемый способ установки Node.js и npm - это использование менеджера версий Node (nvm). Как только вы установите nvm, он будет обрабатывать все зависимости и обновления за вас. Следуйте инструкциям, приведенным на сайте http://nvm.sh.
После установки nvm на вашу операционную систему установка Node.js проста. Используйте флаг --lts, чтобы указать nvm, что вам нужна самая последняя версия Node.js с &quot;долгосрочной поддержкой&quot; (LTS):
$ nvm install --lts</p>
<p>Убедитесь, что у вас установлены node и npm:
$ node -v
v12.16.1
$ npm -v
6.13.4</p>
<p>Далее создайте скрытый файл .nvmrc, содержащий версию Node.js, поддерживаемую вашим DApp, чтобы разработчикам достаточно было запустить nvm install в корне каталога проекта, и он автоматически установится и переключится на использование этой версии:
$ node -v &gt; .nvmrc
$ nvm install</p>
<p>Выглядит хорошо. Теперь нужно установить Truffle:
$ npm -g install truffle</p>
<ul>
<li>truffle@5.1.20
добавлено 26 пакетов от 438 участников и обновлен 1 пакет за 24,229 с</li>
</ul>
<p>Интеграция готового проекта Truffle (Truffle Box)
Если вы хотите использовать или создать DApp, который строится на основе готовых шаблонов, зайдите на сайт Truffle Boxes, выберите существующий проект Truffle, а затем выполните следующую команду, чтобы загрузить и извлечь его:
$ truffle unbox BOX_NAME</p>
<p>Создание каталога проекта Truffle
Для каждого проекта, в котором вы будете использовать Truffle, создайте каталог проекта и инициализируйте Truffle в этом каталоге. Truffle создаст необходимую структуру каталогов внутри каталога проекта. Обычно принято давать каталогу проекта имя, которое описывает проект. В этом примере мы будем использовать Truffle для развертывания нашего контракта Faucet из [simple_contract_example], поэтому мы назовем папку проекта Faucet:
$ mkdir Faucet
$ cd Смеситель
Кран $</p>
<p>Попав в каталог Faucet, мы инициализируем Truffle:
Смеситель $ truffle init</p>
<p>Truffle создает структуру каталогов и некоторые файлы по умолчанию:
Смеситель
+---- контракты
| <code>---- Migrations.sol +---- миграции | </code>---- 1_initial_migration.js
+---- тест
`---- truffle-config.js
Помимо самого Truffle мы будем использовать ряд пакетов поддержки JavaScript (Node.js). Мы можем установить их с помощью npm. Мы инициализируем структуру каталогов npm и принимаем значения по умолчанию, предложенные npm:
$ npm init</p>
<p>название упаковки: (смеситель)
версия: (1.0.0)
описание:
точка входа: (truffle-config.js)
тестовая команда:
git-репозиторий:
ключевые слова:
автор:
лицензия: (ISC)
Сейчас будет произведена запись в Faucet/package.json:</p>
<p>{
&quot;имя&quot;: &quot;кран&quot;,
&quot;версия&quot;: &quot;1.0.0&quot;,
&quot;описание&quot;: &quot;&quot;,
&quot;main&quot;: &quot;truffle-config.js&quot;,
&quot;директории&quot;: {
&quot;тест&quot;: &quot;тест&quot;
},
&quot;скрипты&quot;: {
&quot;test&quot;: &quot;echo &quot;Ошибка: тест не указан&quot; &amp;&amp; exit 1&quot;.
},
&quot;Автор&quot;: &quot;&quot;,
&quot;лицензия&quot;: &quot;ISC&quot;
}</p>
<p>Это нормально? (да)</p>
<p>Теперь мы можем установить зависимости, которые мы будем использовать для облегчения работы с Truffle:
$ npm install dotenv truffle-wallet-provider ethereumjs-wallet</p>
<p>Теперь у нас есть каталог node_modules с несколькими тысячами файлов внутри нашего каталога Faucet.
Перед развертыванием DApp в облачной производственной среде или среде непрерывной интеграции важно указать поле engines, чтобы ваш DApp был собран с правильной версией Node.js и были установлены связанные с ним зависимости. Подробнее о настройке этого поля см. в документации.
Конфигурирование трюфеля
Truffle создает пустой файл конфигурации, truffle-config.js. Теперь мы отредактируем truffle-config.js и заменим его содержимое примером конфигурации, показанным здесь:
module.exports = {
сети: {
localnode: { // К какой сети подключается наш локальный узел
network_id: &quot;*&quot;, // Искать любой идентификатор сети
host: &quot;localhost&quot;,
порт: 8545,
}
}
};
Эта конфигурация является хорошей отправной точкой. Она устанавливает одну сеть Ethereum по умолчанию (с именем localnode), которая предполагает, что мы запускаем клиент Ethereum, такой как Parity, либо как полный узел, либо как легкий клиент. Эта конфигурация предписывает Truffle взаимодействовать с локальным узлом через RPC на порту 8545. Truffle будет использовать любую сеть Ethereum, к которой подключен локальный узел, например, основную сеть Ethereum или тестовую сеть, такую как Ropsten. Локальный узел также будет обеспечивать функциональность кошелька.
В следующих разделах мы настроим дополнительные сети для использования Truffle, такие как локальный тестовый блокчейн ganache и Infura, поставщик хостинговых сетей. По мере добавления новых сетей конфигурационный файл будет становиться все сложнее, но это также даст нам больше возможностей для рабочего процесса тестирования и разработки.
Использование Truffle для развертывания контракта
Теперь у нас есть основной рабочий каталог для нашего проекта Faucet, и мы настроили Truffle и его зависимости. Контракты находятся в подкаталоге contracts нашего проекта. В каталоге уже содержится &quot;вспомогательный&quot; контракт Migrations.sol, который управляет обновлением контрактов за нас. Мы рассмотрим использование Migrations.sol в следующем разделе.
Давайте скопируем контракт Faucet.sol (из [solidity_faucet_example]) в подкаталог contracts, чтобы каталог проекта выглядел следующим образом:
Смеситель
+---- контракты
| +---- Faucet.sol
| `---- Migrations.sol
...
Теперь мы можем попросить Truffle составить для нас договор:
$ truffle compile
Компиляция ./contracts/Faucet.sol...
Компиляция ./contracts/Migrations.sol...
Запись артефактов в ./build/contracts</p>
<p>Миграции Truffle - понимание сценариев развертывания
Truffle предлагает систему развертывания, называемую миграцией. Если вы работали с другими фреймворками, вы могли видеть нечто подобное: Ruby on Rails, Python Django и многие другие языки и фреймворки имеют команду migrate.
Во всех этих системах цель миграции заключается в обработке изменений в схеме данных между различными версиями программного обеспечения. Цель миграций в Ethereum несколько иная. Поскольку контракты Ethereum неизменяемы и требуют больших затрат на развертывание, Truffle предлагает механизм миграции для отслеживания того, какие контракты (и какие версии) уже были развернуты. В сложном проекте с десятками контрактов и сложными зависимостями вы не захотите платить за повторное развертывание контрактов, которые не изменились. Вы также не захотите вручную отслеживать, какие версии каких контрактов уже были развернуты. Механизм миграции Truffle делает все это путем развертывания интеллектуального контракта Migrations.sol, который затем отслеживает все остальные развертывания контрактов.
У нас только один контракт, Faucet.sol, что означает, что система миграции, мягко говоря, излишняя. К сожалению, мы вынуждены ее использовать. Но, научившись использовать ее для одного контракта, мы можем начать практиковать некоторые хорошие привычки для нашего рабочего процесса разработки. Усилия окупятся, когда все усложнится.
Каталог migrations в Truffle - это место, где находятся скрипты миграции. В настоящее время существует только один скрипт, 1_initial_migration.js, который сам развертывает контракт Migrations.sol:
link:code/truffle/Faucet/migrations/1_initial_migration.js[]
Нам нужен второй сценарий миграции, чтобы развернуть Faucet.sol. Назовем его 2_deploy_contracts.js. Он очень прост, как и 1_initial_migration.js, только с несколькими небольшими изменениями. Фактически, вы можете скопировать содержимое 1_initial_migration.j и просто заменить все экземпляры Migrations на Faucet:
link:code/truffle/Faucet/migrations/2_deploy_contracts.js[]
Сценарий инициализирует переменную Faucet, определяя исходный код Faucet.sol Solidity как артефакт, определяющий Faucet. Затем он вызывает функцию deploy для развертывания этого контракта.
Все готово. Давайте используем truffle migrate для его развертывания. Мы должны указать, в какой сети развернуть контракт, используя аргумент --network. В конфигурационном файле у нас указана только одна сеть, которую мы назвали localnode. Убедитесь, что ваш локальный клиент Ethereum запущен, а затем введите:
Faucet $ truffle migrate --network localnode</p>
<p>Поскольку мы используем локальный узел для подключения к сети Ethereum и управления нашим кошельком, нам необходимо авторизовать транзакцию, которую создает Truffle. Мы запускаем Parity, подключенный к тестовому блокчейну Ropsten, поэтому во время миграции мы увидим всплывающее окно, подобное тому, что есть в Parity, с просьбой подтвердить развертывание Faucet на веб-консоли Parity.</p>
<p>Рисунок 1. Паритет запрашивает подтверждение для развертывания Faucet
Всего существует четыре транзакции: одна для развертывания Migrations, одна для обновления счетчика развертываний до 1, одна для развертывания Faucet и одна для обновления счетчика развертываний до 2.
Truffle покажет завершение миграции, покажет каждую транзакцию и адреса контрактов:
$ truffle migrate --network localnode
Использование сети 'localnode'.</p>
<p>Запуск миграции: 1_initial_migration.js
Развертывание миграций...
... 0xfa090db179d023d2abae543b4a21a1479e70ca7d35a469a5d1a98bfc6bd80fe8
Миграции: 0x8861c27715550bed8362c0345add158489df6db0
Сохранение успешной миграции в сеть...
... 0x985c4a32716826ddbe4eae284104bef8bc69e959899f62246a1b27c9dfcd6c03
Сохранение артефактов...
Выполняемая миграция: 2_deploy_contracts.js
Развертывание смесителя...
... 0xecdbeef77f0558edc689440e34b7bba0a3ba7a45e4b680b071b47c30a930e9d6
Faucet: 0xd01cd8e7bd29e4bff8c1693f59eee46137a9f300
Сохранение успешной миграции в сеть...
... 0x11f376bd7307edddfd40dc4a14c3f7cb84b6c921ac2465602060b67d08f9fd8a
Сохранение артефактов...</p>
<p>Использование консоли Truffle
Truffle предлагает консоль JavaScript, которую мы можем использовать для взаимодействия с сетью Ethereum (через локальный узел), взаимодействия с развернутыми контрактами и взаимодействия с провайдером кошелька. В нашей текущей конфигурации (localnode) узел и провайдер кошелька - это наш локальный клиент Parity.
Давайте запустим консоль Truffle и попробуем выполнить несколько команд:
$ truffle console --network localnode
truffle(localnode)&gt;</p>
<p>Truffle выдает подсказку, показывающую выбранную конфигурацию сети (localnode).
Совет
Важно помнить и осознавать, какую сеть вы используете. Вы же не хотите случайно развернуть тестовый контракт или провести транзакцию в основной сети Ethereum. Это может стать дорогостоящей ошибкой!</p>
<p>Консоль Truffle предлагает функцию автозавершения, которая облегчает нам изучение среды. Если после частично выполненной команды нажать Tab, Truffle выполнит команду за нас. Нажатие Tab дважды покажет все возможные варианты завершения, если более одной команды соответствует введенным нами данным. На самом деле, если мы дважды нажмем Tab в пустой строке, Truffle выведет список всех доступных команд:
truffle(localnode)&gt;
Array Boolean Date Error EvalError Function Infinity JSON Math NaN Number Object RangeError ReferenceError RegExp String SyntaxError TypeError URIError decodeURI decodeURIComponent encodeURI encodeURIComponent eval isFinite isNaN parseFloat parseInt undefined</p>
<p>ArrayBuffer Buffer DataView Faucet Float32Array Float64Array GLOBAL Int16Array Int32Array Int8Array Intl Map Migrations Promise Proxy Reflect Set StateManager Symbol Uint16Array Uint32Array Uint8Array Uint8ClampedArray WeakMap WeakSet WebAssembly XMLHttpRequest _ assert async_hooks buffer child_process clearImmediate clearInterval clearTimeout cluster console crypto dgram dns domain escape events fs global http http http2 https module net os path perf_hooks process punycode querystring readline repl require root setImmediate setInterval setTimeout stream string_decoder tls tty unescape url util v8 vm web3 zlib</p>
<p><strong>defineGetter</strong> <strong>defineSetter</strong> <strong>lookupGetter</strong> <strong>lookupSetter</strong> <strong>proto</strong> constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf</p>
<p>Подавляющее большинство функций, связанных с кошельком и узлом, обеспечивается объектом web3, который является экземпляром библиотеки web3.js. Объект web3 абстрагирует интерфейс RPC для нашего узла Parity. Вы также заметите два объекта со знакомыми именами: Migrations и Faucet. Они представляют контракты, которые мы только что развернули. Мы будем использовать консоль Truffle для взаимодействия с контрактом. Сначала проверим наш кошелек через объект web3:
truffle(localnode)&gt; web3.eth.accounts
[ '0x9e713963a92c02317a681b9bb3065a8249de124f',
'0xdb5dc1a13e3a55cf3b4587cd8d1e5fdeb6738145' ]</p>
<p>Наш клиент Parity имеет два кошелька, с некоторым количеством тестового эфира на Ropsten. Атрибут web3.eth.accounts содержит список всех счетов. Мы можем проверить баланс первого счета с помощью функции getBalance:
truffle(localnode)&gt; web3.eth.getBalance(web3.eth.accounts[0]).toNumber()
191198572800000000
truffle(localnode)&gt;</p>
<p>web3.js - это большая библиотека JavaScript, которая предлагает комплексный интерфейс к системе Ethereum через провайдера, например, локальный клиент. Более подробно мы рассмотрим web3.js в [web3js_tutorial]. Теперь давайте попробуем взаимодействовать с нашими контрактами:
truffle(localnode)&gt; Faucet.address
'0xd01cd8e7bd29e4bff8c1693f59eee46137a9f300'
truffle(localnode)&gt; web3.eth.getBalance(Faucet.address).toNumber()
0
truffle(localnode)&gt;</p>
<p>Далее мы используем sendTransaction, чтобы отправить немного тестового эфира для финансирования контракта Faucet. Обратите внимание на использование web3.utils.toWei для конвертации единиц эфира. Ввести 18 нулей без ошибки сложно и опасно, поэтому всегда лучше использовать конвертер единиц измерения. Вот как мы отправляем транзакцию:
truffle(localnode)&gt; web3.eth.sendTransaction({from:web3.eth.accounts[0],
to:Faucet.address, value:web3.utils.toWei(0.5, 'ether')});
'0xf134c75b985dc0e0c27c2f0412251e0860eb530a5055e660f21e7483ab336808'</p>
<p>Если мы переключимся на веб-интерфейс Parity, то увидим всплывающее окно с просьбой подтвердить эту транзакцию. Как только транзакция будет добыта, мы сможем увидеть баланс нашего контракта Faucet:
truffle(localnode)&gt; web3.eth.getBalance(Faucet.address).toNumber()
500000000000000000</p>
<p>Теперь вызовем функцию withdraw, чтобы вывести из контракта тестовый эфир:
truffle(localnode)&gt; Faucet.deployed().then(instance =&gt;
{instance.withdraw(web3.utils.toWei(0.1,
'эфир'))}).then(console.log)</p>
<p>Опять же, нам нужно будет одобрить транзакцию в веб-интерфейсе Parity. Если мы проверим еще раз, то увидим, что баланс контракта Faucet уменьшился, а на наш тестовый кошелек поступило 0,1 эфира:
truffle(localnode)&gt; web3.eth.getBalance(Faucet.address).toNumber()
400000000000000000
truffle(localnode)&gt; Faucet.deployed().then(instance =&gt;
{instance.withdraw(web3.utils.toWei(1, 'ether'))})
СтатусОшибка: Транзакция: 0xe147ae9e3610334...8612b92d3f9c
завершилась с ошибкой (статус 0).</p>
<h3 id="embark"><a class="header" href="#embark">Embark</a></h3>
<p>GitHub: https://github.com/embark-framework/embark/
Документация: https://embark.status.im/docs/
Репозиторий пакетов npm: https://www.npmjs.com/package/embark
Embark - это фреймворк, созданный для того, чтобы разработчики могли легко разрабатывать и внедрять децентрализованные приложения. Embark интегрируется с Ethereum, IPFS, Whisper и Swarm и предлагает следующие возможности:
Автоматически развертывайте контракты и делайте их доступными в JS-коде.
Следите за изменениями и при необходимости обновляйте контракты для перераспределения.
Управление и взаимодействие с различными сетями (например, testnet, local, mainnet).
Управлять сложными системами взаимозависимых контрактов.
Хранить и извлекать данные, включая загрузку и извлечение файлов, размещенных в IPFS.
Облегчает процесс развертывания полного приложения на IPFS или Swarm.
Отправляйте и получайте сообщения через Whisper.
Вы можете установить его с помощью npm:</p>
<pre><code>$ npm -g install embark
</code></pre>
<h3 id="openzeppelin"><a class="header" href="#openzeppelin">OpenZeppelin</a></h3>
<p>GitHub: https://github.com/OpenZeppelin/openzeppelin-solidity
Веб-сайт: https://openzeppelin.org/
Документация: https://openzeppelin.org/api/docs/open-zeppelin.html
OpenZeppelin - это открытая структура многократно используемых и безопасных смарт-контрактов на языке Solidity.
Он создан на базе сообщества, возглавляемого командой Zeppelin и имеющего более сотни внешних участников. Основное внимание в фреймворке уделяется безопасности, которая достигается путем применения стандартных для отрасли моделей безопасности контрактов и лучших практик, опираясь на весь опыт разработчиков Zeppelin, полученный в ходе аудита огромного количества контрактов, а также путем постоянного тестирования и аудита со стороны сообщества, которое использует фреймворк в качестве основы для своих реальных приложений.
Фреймворк OpenZeppelin является наиболее распространенным решением для смарт-контрактов Ethereum. В настоящее время фреймворк имеет обширную библиотеку контрактов, включая реализацию токенов ERC20 и ERC721, множество вариантов моделей краудсейла, а также простые модели поведения, обычно встречающиеся в таких контрактах, как Ownable, Pausable или LimitBalance. Контракты в этом репозитории в некоторых случаях функционируют как де-факто стандартные реализации.
Фреймворк лицензирован под лицензией MIT, а все контракты были разработаны с использованием модульного подхода, чтобы гарантировать простоту повторного использования и расширения. Это чистые и базовые строительные блоки, готовые к использованию в вашем следующем проекте Ethereum. Давайте настроим фреймворк и создадим простой краудсейл с использованием контрактов OpenZeppelin, чтобы продемонстрировать, насколько он прост в использовании. Этот пример также подчеркивает важность повторного использования безопасных компонентов вместо их самостоятельного написания.
Во-первых, нам нужно установить библиотеку openzeppelin-solidity в наше рабочее пространство. Последняя версия на момент написания этой статьи - v1.9.0, поэтому мы будем использовать именно ее:
$ mkdir sample-crowdsale
$ cd sample-crowdsale
$ npm install openzeppelin-solidity@1.9.0
$ mkdir contracts</p>
<p>На момент написания статьи OpenZeppelin включает в себя несколько базовых контрактов с токенами, которые соответствуют стандартам ERC20, ERC721 и ERC827, с различными характеристиками для эмиссии, лимитов, наделения, жизненного цикла и т.д.
Давайте создадим токен ERC20, который можно майнить, то есть первоначальное предложение начинается с 0, а новые токены могут быть созданы владельцем токена (в нашем случае - контрактом краудсейла) и проданы покупателям. Для этого мы создадим файл contracts/SampleToken.sol со следующим содержимым:
link:code/OpenZeppelin/contracts/SampleToken.sol[]
OpenZeppelin уже предоставляет контракт MintableToken, который мы можем использовать в качестве основы для нашего токена, поэтому мы определяем только детали, специфичные для нашего случая. Далее, давайте создадим контракт краудсейла. Как и в случае с токенами, OpenZeppelin уже предоставляет широкий выбор вариантов краудсейла. В настоящее время вы найдете контракты для различных сценариев, связанных с распределением, эмиссией, ценой и проверкой. Итак, допустим, вы хотите установить цель для вашего краудсейла, и если она не будет достигнута к моменту завершения продажи, вы хотите вернуть деньги всем своим инвесторам. Для этого вы можете использовать контракт RefundableCrowdsale. Или, возможно, вы хотите организовать краудсейл с растущей ценой, чтобы стимулировать ранних покупателей; для этого существует контракт IncreasingPriceCrowdsale. Вы также можете завершить краудсейл, когда контракт получит определенное количество эфира (CappedCrowdsale), или установить время окончания с помощью контракта TimedCrowdsale, или создать белый список покупателей с помощью контракта WhitelistedCrowdsale.
Как мы уже говорили, контракты OpenZeppelin - это базовые строительные блоки. Эти контракты краудсейла были разработаны для комбинирования; просто прочитайте исходный код базового контракта краудсейла, чтобы узнать, как его расширить. Для краудсейла нашего токена нам нужно чеканить токены, когда эфир поступает на контракт краудсейла, поэтому в качестве основы возьмем MintedCrowdsale. А чтобы сделать его более интересным, давайте также сделаем его PostDeliveryCrowdsale, чтобы токены можно было вывести только после окончания краудсейла. Для этого мы напишем следующее в файле contracts/SampleCrowdsale.sol:
link:code/OpenZeppelin/contracts/SampleCrowdsale.sol[]
Опять же, нам почти не пришлось писать никакого кода; мы просто повторно использовали проверенный в боях код, который предоставило сообщество OpenZeppelin. Однако важно отметить, что этот случай отличается от случая с нашим контрактом SampleToken. Если вы обратитесь к автоматизированным тестам Crowdsale, то увидите, что они тестируются изолированно. Когда вы интегрируете различные части кода в более крупный компонент, недостаточно тестировать все части отдельно, потому что взаимодействие между ними может вызвать поведение, которого вы не ожидали. В частности, вы увидите, что здесь мы ввели множественное наследование, что может удивить разработчика, если он не понимает деталей Solidity. Наш контракт SampleCrowdsale прост, и он будет работать так, как мы ожидаем, потому что фреймворк был разработан для того, чтобы сделать такие случаи простыми; но не ослабляйте бдительность из-за простоты, которую привносит этот фреймворк. Каждый раз, когда вы интегрируете части фреймворка OpenZeppelin для создания более сложного решения, вы должны полностью протестировать каждый аспект вашего решения, чтобы убедиться, что все взаимодействия модулей работают так, как вы задумали.
Наконец, когда мы довольны нашим решением и тщательно его протестировали, нам нужно развернуть его. OpenZeppelin хорошо интегрируется с Truffle, поэтому мы можем просто написать файл миграций, подобный следующему (migrations/2_deploy_contracts.js), как объясняется в разделе Миграции Truffle - понимание сценариев развертывания:
link:code/OpenZeppelin/migrations/2_deploy_contracts.js[]
Примечание
Это был лишь краткий обзор нескольких контрактов, которые являются частью фреймворка OpenZeppelin. Приглашаем вас присоединиться к сообществу разработчиков OpenZeppelin, чтобы учиться и вносить свой вклад.</p>
<h3 id="zeppelinos"><a class="header" href="#zeppelinos">ZeppelinOS</a></h3>
<p>GitHub: https://github.com/zeppelinos
Веб-сайт: https://zeppelinos.org
Блог: https://blog.zeppelinos.org
ZeppelinOS - это &quot;распределенная платформа инструментов и сервисов с открытым исходным кодом поверх EVM для безопасной разработки и управления приложениями смарт-контрактов&quot;.
В отличие от кода OpenZeppelin, который необходимо развертывать с каждым приложением при каждом использовании, код ZeppelinOS живет на цепочке. Приложениям, которым нужна определенная функциональность - например, токен ERC20 - не только не нужно переделывать и перепроверять его реализацию (то, что решает OpenZeppelin), но даже не нужно его развертывать. В ZeppelinOS приложение взаимодействует с реализацией токена на цепочке напрямую, примерно так же, как настольное приложение взаимодействует с компонентами своей базовой ОС.
В основе ZeppelinOS лежит очень умный контракт, известный как прокси. Прокси - это контракт, который способен обернуть любой другой контракт, раскрыть его интерфейс без необходимости вручную реализовывать для него сеттеры и геттеры, и может обновлять его без потери состояния. В терминах Solidity это можно рассматривать как обычный контракт, бизнес-логика которого содержится в библиотеке, которую в любой момент можно поменять на новую библиотеку без потери состояния. Способ, которым прокси связывается со своей реализацией, полностью автоматизирован и инкапсулирован для разработчика. Практически любой контракт можно сделать обновляемым практически без изменений в его коде. Подробнее о механизме прокси в ZeppelinOS можно прочитать в блоге, а пример его использования можно найти на GitHub.
Разработка приложений с помощью ZeppelinOS похожа на разработку приложений JavaScript с помощью npm. AppManager обрабатывает пакет приложения для каждой версии приложения. Пакет - это просто каталог контрактов, каждый из которых может иметь один или несколько обновляемых прокси. AppManager не только предоставляет прокси для контрактов, специфичных для приложения, но и делает это для реализаций ZeppelinOS в виде стандартной библиотеки. Чтобы увидеть полный пример этого, пожалуйста, посетите examples/complex.
Хотя в настоящее время ZeppelinOS находится в стадии разработки, она стремится предоставить широкий набор дополнительных функций, таких как инструменты разработчика, планировщик, автоматизирующий фоновые операции в рамках контрактов, вознаграждения за разработку, рынок, облегчающий общение и обмен ценностями между приложениями, и многое другое. Все это описано в техническом документе ZeppelinOS.</p>
<h2 id="Утилиты"><a class="header" href="#Утилиты">Утилиты</a></h2>
<h3 id="ethereumjs-helpeth-Утилита-командной-строки"><a class="header" href="#ethereumjs-helpeth-Утилита-командной-строки">EthereumJS helpeth: Утилита командной строки</a></h3>
<p>GitHub: https://github.com/ethereumjs/helpeth
helpeth - это инструмент командной строки для работы с ключами и транзакциями, который значительно облегчает работу разработчика.
Он является частью коллекции библиотек и инструментов EthereumJS на базе JavaScript:</p>
<pre><code>Usage: helpeth [command]

Commands:
  signMessage &lt;message&gt;                     Sign a message
  verifySig &lt;hash&gt; &lt;sig&gt;                    Verify signature
  verifySigParams &lt;hash&gt; &lt;r&gt; &lt;s&gt; &lt;v&gt;        Verify signature parameters
  createTx &lt;nonce&gt; &lt;to&gt; &lt;value&gt; &lt;data&gt;      Sign a transaction
  &lt;gasLimit&gt; &lt;gasPrice&gt;
  assembleTx &lt;nonce&gt; &lt;to&gt; &lt;value&gt; &lt;data&gt;    Assemble a transaction from its
  &lt;gasLimit&gt; &lt;gasPrice&gt; &lt;v&gt; &lt;r&gt; &lt;s&gt;         components
  parseTx &lt;tx&gt;                              Parse raw transaction
  keyGenerate [format] [icapdirect]         Generate new key
  keyConvert                                Convert a key to V3 keystore format
  keyDetails                                Print key details
  bip32Details &lt;path&gt;                       Print key details for a given path
  addressDetails &lt;address&gt;                  Print details about an address
  unitConvert &lt;value&gt; &lt;from&gt; &lt;to&gt;           Convert between Ethereum units

Options:
  -p, --private      Private key as a hex string                        [string]
  --password         Password for the private key                       [string]
  --password-prompt  Prompt for the private key password               [boolean]
  -k, --keyfile      Encoded key file                                   [string]
  --show-private     Show private key details                          [boolean]
  --mnemonic         Mnemonic for HD key derivation                     [string]
  --version          Show version number                               [boolean]
  --help             Show help                                         [boolean]
</code></pre>
<h3 id="dapptools"><a class="header" href="#dapptools">dapp.tools</a></h3>
<p>Веб-сайт: https://dapp.tools/
dapp.tools - это полный набор инструментов для разработчиков блокчейна, созданный в духе философии Unix. В него входят следующие инструменты:</p>
<h4 id="dapp"><a class="header" href="#dapp">Dapp</a></h4>
<p>Dapp - это основной пользовательский инструмент для создания новых DApps, запуска модульных тестов Solidity, отладки и развертывания контрактов, запуска тестовых сетей и многого другого.</p>
<h4 id="seth"><a class="header" href="#seth">Seth</a></h4>
<p>Seth используется для составления транзакций, запросов к блокчейну, конвертации между форматами данных, выполнения удаленных вызовов и подобных повседневных задач.</p>
<h4 id="hevm"><a class="header" href="#hevm">Hevm</a></h4>
<p>Hevm - это реализация EVM на языке Haskell с удобным терминальным отладчиком Solidity. Он используется для тестирования и отладки DApps.</p>
<h4 id="evmdis"><a class="header" href="#evmdis">evmdis</a></h4>
<p>evmdis - это дизассемблер EVM; он выполняет статический анализ байткода для обеспечения более высокого уровня абстракции, чем необработанные операции EVM.</p>
<h3 id="sputnikvm"><a class="header" href="#sputnikvm">SputnikVM</a></h3>
<p>SputnikVM - это автономная подключаемая виртуальная машина для различных блокчейнов на базе Ethereum. Она написана на языке Rust и может использоваться как двоичный файл, карго-крейт, общая библиотека или интегрироваться через интерфейсы FFI, Protobuf и JSON. У него есть отдельный бинарник, sputnikvm-dev, предназначенный для тестирования, который эмулирует большую часть JSON-RPC API и блокчейн.</p>
<h2 id="Библиотеки"><a class="header" href="#Библиотеки">Библиотеки</a></h2>
<h3 id="web3js"><a class="header" href="#web3js">web3.js</a></h3>
<p>web3.js - это совместимый с Ethereum JavaScript API для связи с клиентами через JSON-RPC, разработанный Ethereum Foundation.
GitHub: https://github.com/ethereum/web3.js
Репозиторий пакетов npm: https://www.npmjs.com/package/web3
Документация для web3.js API 0.2x.x: http://bit.ly/2Qcyq1C
Документация для web3.js API 1.0.0-beta.xx: http://bit.ly/2CT33p0.</p>
<h3 id="web3py"><a class="header" href="#web3py">web3.py</a></h3>
<p>web3.py - это библиотека Python для взаимодействия с блокчейном Ethereum, поддерживаемая Ethereum Foundation.
GitHub: https://github.com/ethereum/web3.py
PyPi: https://pypi.python.org/pypi/web3/4.0.0b9
Документация: https://web3py.readthedocs.io/</p>
<h3 id="ethereumjs"><a class="header" href="#ethereumjs">EthereumJS</a></h3>
<p>EthereumJS - это коллекция библиотек и утилит для Ethereum.
GitHub: https://github.com/ethereumjs
Веб-сайт: https://ethereumjs.github.io/</p>
<h3 id="web3j"><a class="header" href="#web3j">web3j</a></h3>
<p>web3j - это библиотека для Java и Android для интеграции с клиентами Ethereum и работы со смарт-контрактами.
GitHub: https://github.com/web3j/web3j
Веб-сайт: https://web3j.io
Документация: https://docs.web3j.io</p>
<h3 id="etherjar"><a class="header" href="#etherjar">EtherJar</a></h3>
<p>EtherJar - это еще одна библиотека Java для интеграции с Ethereum и работы со смарт-контрактами. Она предназначена для серверных проектов на базе Java 8+ и обеспечивает низкоуровневый доступ и высокоуровневую обертку вокруг RPC, структур данных Ethereum и доступа к смарт-контрактам.
GitHub: https://github.com/infinitape/etherjar</p>
<h3 id="nethereum"><a class="header" href="#nethereum">Nethereum</a></h3>
<p>Nethereum - это библиотека интеграции .Net для Ethereum.
GitHub: https://github.com/Nethereum/Nethereum
Веб-сайт: http://nethereum.com/
Документация: https://nethereum.readthedocs.io/en/latest/</p>
<h3 id="ethersjs"><a class="header" href="#ethersjs">ethers.js</a></h3>
<p>Библиотека ethers.js - это компактная, полная, полнофункциональная, тщательно протестированная библиотека Ethereum с лицензией MIT, которая получила грант DevEx от Ethereum Foundation на ее расширение и поддержку.
Ссылка на GitHub: https://github.com/ethers-io/ethers.js
Документация: https://docs.ethers.io</p>
<h3 id="Изумрудная-платформа"><a class="header" href="#Изумрудная-платформа">Изумрудная платформа</a></h3>
<p>Emerald Platform предоставляет библиотеки и компоненты пользовательского интерфейса для создания DApps поверх Ethereum. Emerald JS и Emerald JS UI предоставляют наборы модулей и компонентов React для создания приложений и веб-сайтов на JavaScript; Emerald SVG Icons - набор иконок, связанных с блокчейном. В дополнение к библиотекам JavaScript Emerald имеет библиотеку Rust для работы с закрытыми ключами и подписями транзакций. Все библиотеки и компоненты Emerald лицензированы по лицензии Apache License, версия 2.0.
GitHub: https://github.com/etcdevteam/emerald-platform
Документация: https://docs.etcdevteam.com</p>
<h2 id="Тестирование-смарт-контрактов"><a class="header" href="#Тестирование-смарт-контрактов">Тестирование смарт-контрактов</a></h2>
<p>Для разработки смарт-контрактов существует несколько широко используемых тестовых фреймворков, которые приведены в кратком обзоре тестовых фреймворков для смарт-контрактов:</p>
<p>Таблица 1. Сводная информация о механизмах тестирования смарт-контрактов</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Framework</th><th style="text-align: center">Языки тестирования</th><th>Система тестирования</th><th style="text-align: center">Эмулятор цепи</th><th style="text-align: center">Страница</th></tr></thead><tbody>
<tr><td style="text-align: center">Truffle</td><td style="text-align: center">JavaScript/Solidity</td><td>Mocha</td><td style="text-align: center">TestRPC/Ganache</td><td style="text-align: center"><a href="https://trufflesuite.com/">https://trufflesuite.com/</a></td></tr>
<tr><td style="text-align: center">Embark</td><td style="text-align: center">JavaScript</td><td>Mocha</td><td style="text-align: center">TestRPC/Ganache</td><td style="text-align: center">https://embark.status.im/docs/</td></tr>
<tr><td style="text-align: center">Dapp</td><td style="text-align: center">Solidity</td><td>ds-test (custom)</td><td style="text-align: center">ethrun (Parity)</td><td style="text-align: center">https://dapp.tools/dapp/</td></tr>
<tr><td style="text-align: center">Populus</td><td style="text-align: center">Python</td><td>pytest</td><td style="text-align: center">Python chain emulator</td><td style="text-align: center">https://populus.readthedocs.io</td></tr>
</tbody></table>
</div>
<h4 id="Трюфель-1"><a class="header" href="#Трюфель-1">Трюфель</a></h4>
<p>Truffle позволяет писать модульные тесты на JavaScript (на основе Mocha) или Solidity. Эти тесты запускаются на Ganache.</p>
<h4 id="embark-1"><a class="header" href="#embark-1">Embark</a></h4>
<p>Embark интегрируется с Mocha для запуска модульных тестов, написанных на JavaScript. Тесты, в свою очередь, запускаются против контрактов, развернутых на Ganache (ранее называвшемся TestRPC). Фреймворк Embark автоматически развертывает смарт-контракты и автоматически перераспределяет контракты при их изменении. Он также отслеживает развернутые контракты и развертывает их только тогда, когда это действительно необходимо. Embark включает библиотеку тестирования для быстрого запуска и проверки ваших контрактов в EVM, с такими функциями, как assert.equal. Команда embark test запустит все тестовые файлы в каталоге test.</p>
<h4 id="dapp-1"><a class="header" href="#dapp-1">Dapp</a></h4>
<p>Dapp использует собственный код Solidity (библиотека под названием ds-test) и созданную Parity библиотеку Rust под названием ethrun для выполнения байткода Ethereum и последующего подтверждения корректности. Библиотека ds-test предоставляет функции assertion для проверки корректности и события для регистрации данных в консоли.</p>
<p>Функции утверждения включают:</p>
<pre><code>assert(bool condition)
assertEq(адрес a, адрес b)
assertEq(bytes32 a, bytes32 b)
assertEq(int a, int b)
assertEq(uint a, uint b)
assertEq0(байт a, байт b)
expectEventsExact(address target)
</code></pre>
<p>Команды протоколирования выводят информацию на консоль, что делает их полезными для отладки:</p>
<pre><code>logs(bytes)
log_bytes32(bytes32)
log_named_bytes32(bytes32 key, bytes32 val)
log_named_address(bytes32 key, address val)
log_named_int(bytes32 key, int val)
log_named_uint(bytes32 key, uint val)
log_named_decimal_int(bytes32 key, int val, uint decimals)
log_named_decimal_uint(bytes32 key, uint val, uint decimals)
</code></pre>
<h4 id="populus"><a class="header" href="#populus">Populus</a></h4>
<p>Populus использует Python и собственный эмулятор цепочки для выполнения контрактов, написанных на Solidity. Юнит-тесты пишутся на Python с помощью библиотеки pytest. Populus поддерживает написание контрактов специально для тестирования. Имена этих контрактов должны соответствовать шаблону glob Test*.sol и располагаться в любом месте каталога тестов проекта, tests.</p>
<h3 id="Тестирование-на-блокчейне"><a class="header" href="#Тестирование-на-блокчейне">Тестирование на блокчейне</a></h3>
<p>Хотя большинство тестов не должно проводиться на развернутых контрактах, поведение контракта можно проверить с помощью клиентов Ethereum. Для оценки состояния смарт-контракта можно использовать следующие команды. Эти команды следует набирать в терминале geth, хотя любая консоль web3 также поддерживает их.</p>
<p>Чтобы получить адрес контракта в txhash, используйте:</p>
<p><code>web3.eth.getTransactionReceipt(txhash);</code></p>
<p>Эта команда получает код контракта, развернутого по адресу contractaddress; его можно использовать для проверки правильности развертывания:</p>
<p><code>web3.eth.getCode(contractaddress)</code> </p>
<p>Это позволяет получить полный журнал контракта, расположенного по адресу, указанному в опциях, что полезно для просмотра истории вызовов контракта:</p>
<p><code>web3.eth.getPastLogs(options)</code></p>
<p>Наконец, эта команда получает хранилище, расположенное по адресу со смещением позиции:</p>
<p><code>web3.eth.getStorageAt(address, position)</code> </p>
<h3 id="Ганаш-локальный-тестовый-блокчейн"><a class="header" href="#Ганаш-локальный-тестовый-блокчейн">Ганаш: локальный тестовый блокчейн</a></h3>
<p>Ganache - это локальный тестовый блокчейн, который можно использовать для развертывания контрактов, разработки приложений и проведения тестов. Он доступен в виде настольного приложения (с графическим интерфейсом пользователя) для Windows, macOS и Linux. Он также доступен в виде утилиты командной строки под названием ganache-cli. Более подробную информацию и инструкции по установке настольного приложения Ganache можно найти на сайте https://trufflesuite.com/ganache.
Код ganache-cli можно найти по адресу https://github.com/trufflesuite/ganache-cli/.
Чтобы установить ganache-cli из командной строки, используйте npm:</p>
<pre><code>$ npm install -g ganache-cli
</code></pre>
<p>Вы можете использовать ganache-cli для запуска локального блокчейна для тестирования следующим образом:</p>
<pre><code>$ ganache-cli \
  --networkId=3 \
  --port=&quot;8545&quot; \
  --verbose \
  --gasLimit=8000000 \
  --gasPrice=4000000000;
</code></pre>
<p>Несколько замечаний по этой командной строке:</p>
<ul>
<li>Проверьте, что значения флагов --networkId и --port соответствуют вашей конфигурации в файле truffle-config.js.</li>
<li>Убедитесь, что значение флага --gasLimit соответствует последнему лимиту газа в сети (например, 8,000,000 газа), показанному на сайте https://ethstats.net, чтобы избежать ненужных исключений &quot;закончился газ&quot;. Обратите внимание, что значение --gasPrice 4000000000 означает цену газа в 4 гвея.</li>
<li>При желании можно ввести значение флага --mnemonic, чтобы восстановить предыдущий кошелек HD и связанные с ним адреса.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../kniga/дополнение_3_коды_evm_и_gas.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../support.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../kniga/дополнение_3_коды_evm_и_gas.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../support.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
